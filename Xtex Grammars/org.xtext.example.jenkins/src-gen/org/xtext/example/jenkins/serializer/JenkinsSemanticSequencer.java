/*
 * generated by Xtext 2.34.0
 */
package org.xtext.example.jenkins.serializer;

import com.google.inject.Inject;
import java.util.Set;
import jenkins_metamodel.AllOf;
import jenkins_metamodel.Any;
import jenkins_metamodel.AnyOf;
import jenkins_metamodel.Axis;
import jenkins_metamodel.BooleanParam;
import jenkins_metamodel.Branch;
import jenkins_metamodel.BuildDiscarder;
import jenkins_metamodel.BuildingTag;
import jenkins_metamodel.ChangeRequest;
import jenkins_metamodel.ChangeSet;
import jenkins_metamodel.Changelog;
import jenkins_metamodel.CheckoutToSubdirectory;
import jenkins_metamodel.ChoiceParam;
import jenkins_metamodel.Command;
import jenkins_metamodel.Cron;
import jenkins_metamodel.DisableConcurrentBuilds;
import jenkins_metamodel.DisableRestartFromStage;
import jenkins_metamodel.DisableResume;
import jenkins_metamodel.Docker;
import jenkins_metamodel.Dockerfile;
import jenkins_metamodel.Environment;
import jenkins_metamodel.Equals;
import jenkins_metamodel.Expression;
import jenkins_metamodel.Input;
import jenkins_metamodel.Jenkins_metamodelPackage;
import jenkins_metamodel.Label;
import jenkins_metamodel.Matrix;
import jenkins_metamodel.NewContainerPerStage;
import jenkins_metamodel.Node;
import jenkins_metamodel.None;
import jenkins_metamodel.Not;
import jenkins_metamodel.OverrideIndexTriggers;
import jenkins_metamodel.ParallelsAlwaysFailFast;
import jenkins_metamodel.PasswordParam;
import jenkins_metamodel.Pipeline;
import jenkins_metamodel.PollSCM;
import jenkins_metamodel.Post;
import jenkins_metamodel.PreserveStashes;
import jenkins_metamodel.QuietPeriod;
import jenkins_metamodel.Retry;
import jenkins_metamodel.SkipDefaultCheckout;
import jenkins_metamodel.SkipStagesAfterUnstable;
import jenkins_metamodel.Stage;
import jenkins_metamodel.Step;
import jenkins_metamodel.Step_Parameter;
import jenkins_metamodel.StringParam;
import jenkins_metamodel.Tag;
import jenkins_metamodel.TextParam;
import jenkins_metamodel.Timeout;
import jenkins_metamodel.Timestamps;
import jenkins_metamodel.Tool;
import jenkins_metamodel.TriggeredBy;
import jenkins_metamodel.Upstream;
import jenkins_metamodel.When_Env;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.jenkins.services.JenkinsGrammarAccess;

@SuppressWarnings("all")
public class JenkinsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private JenkinsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Jenkins_metamodelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Jenkins_metamodelPackage.ALL_OF:
				sequence_AllOf(context, (AllOf) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.ANY:
				sequence_Any(context, (Any) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.ANY_OF:
				sequence_AnyOf(context, (AnyOf) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.AXIS:
				sequence_Axis(context, (Axis) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.BOOLEAN_PARAM:
				sequence_BooleanParam(context, (BooleanParam) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.BRANCH:
				sequence_Branch(context, (Branch) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.BUILD_DISCARDER:
				sequence_BuildDiscarder(context, (BuildDiscarder) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.BUILDING_TAG:
				sequence_BuildingTag(context, (BuildingTag) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.CHANGE_REQUEST:
				sequence_ChangeRequest(context, (ChangeRequest) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.CHANGE_SET:
				sequence_ChangeSet(context, (ChangeSet) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.CHANGELOG:
				sequence_Changelog(context, (Changelog) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.CHECKOUT_TO_SUBDIRECTORY:
				sequence_CheckoutToSubdirectory(context, (CheckoutToSubdirectory) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.CHOICE_PARAM:
				sequence_ChoiceParam(context, (ChoiceParam) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.CRON:
				sequence_Cron(context, (Cron) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.DISABLE_CONCURRENT_BUILDS:
				sequence_DisableConcurrentBuilds(context, (DisableConcurrentBuilds) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.DISABLE_RESTART_FROM_STAGE:
				sequence_DisableRestartFromStage(context, (DisableRestartFromStage) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.DISABLE_RESUME:
				sequence_DisableResume(context, (DisableResume) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.DOCKER:
				sequence_Docker(context, (Docker) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.DOCKERFILE:
				sequence_Dockerfile(context, (Dockerfile) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.ENVIRONMENT:
				sequence_Environment(context, (Environment) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.EQUALS:
				sequence_Equals(context, (Equals) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.MATRIX:
				sequence_Matrix(context, (Matrix) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.NEW_CONTAINER_PER_STAGE:
				sequence_NewContainerPerStage(context, (NewContainerPerStage) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.NONE:
				sequence_None(context, (None) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.OVERRIDE_INDEX_TRIGGERS:
				sequence_OverrideIndexTriggers(context, (OverrideIndexTriggers) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.PARALLELS_ALWAYS_FAIL_FAST:
				sequence_ParallelsAlwaysFailFast(context, (ParallelsAlwaysFailFast) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.PASSWORD_PARAM:
				sequence_PasswordParam(context, (PasswordParam) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.PIPELINE:
				sequence_Pipeline(context, (Pipeline) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.POLL_SCM:
				sequence_PollSCM(context, (PollSCM) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.POST:
				sequence_Post(context, (Post) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.PRESERVE_STASHES:
				sequence_PreserveStashes(context, (PreserveStashes) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.QUIET_PERIOD:
				sequence_QuietPeriod(context, (QuietPeriod) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.RETRY:
				sequence_Retry(context, (Retry) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.SKIP_DEFAULT_CHECKOUT:
				sequence_SkipDefaultCheckout(context, (SkipDefaultCheckout) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.SKIP_STAGES_AFTER_UNSTABLE:
				sequence_SkipStagesAfterUnstable(context, (SkipStagesAfterUnstable) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.STAGE:
				sequence_Stage(context, (Stage) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.STEP:
				sequence_Step(context, (Step) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.STEP_PARAMETER:
				sequence_Step_Parameter(context, (Step_Parameter) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.STRING_PARAM:
				sequence_StringParam(context, (StringParam) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.TAG:
				sequence_Tag(context, (Tag) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.TEXT_PARAM:
				sequence_TextParam(context, (TextParam) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.TIMEOUT:
				sequence_Timeout(context, (Timeout) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.TIMESTAMPS:
				sequence_Timestamps(context, (Timestamps) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.TOOL:
				sequence_Tool(context, (Tool) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.TRIGGERED_BY:
				sequence_TriggeredBy(context, (TriggeredBy) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.UPSTREAM:
				sequence_Upstream(context, (Upstream) semanticObject); 
				return; 
			case Jenkins_metamodelPackage.WHEN_ENV:
				sequence_When_Env(context, (When_Env) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns AllOf
	 *     AllOf returns AllOf
	 *
	 * Constraint:
	 *     when+=When+
	 * </pre>
	 */
	protected void sequence_AllOf(ISerializationContext context, AllOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns AnyOf
	 *     AnyOf returns AnyOf
	 *
	 * Constraint:
	 *     when+=When+
	 * </pre>
	 */
	protected void sequence_AnyOf(ISerializationContext context, AnyOf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Agent returns Any
	 *     Any returns Any
	 *
	 * Constraint:
	 *     {Any}
	 * </pre>
	 */
	protected void sequence_Any(ISerializationContext context, Any semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Axis returns Axis
	 *
	 * Constraint:
	 *     (name=EString values+=EString values+=EString* exclude?='exclude'?)
	 * </pre>
	 */
	protected void sequence_Axis(ISerializationContext context, Axis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter_Directive returns BooleanParam
	 *     BooleanParam returns BooleanParam
	 *
	 * Constraint:
	 *     (name=EString description=EString? defaultValue?='defaultValue')
	 * </pre>
	 */
	protected void sequence_BooleanParam(ISerializationContext context, BooleanParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns Branch
	 *     Branch returns Branch
	 *
	 * Constraint:
	 *     (pattern=EString comparator=COMPARATOR_TYPE?)
	 * </pre>
	 */
	protected void sequence_Branch(ISerializationContext context, Branch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns BuildDiscarder
	 *     BuildDiscarder returns BuildDiscarder
	 *
	 * Constraint:
	 *     numToKeepStr=EShort
	 * </pre>
	 */
	protected void sequence_BuildDiscarder(ISerializationContext context, BuildDiscarder semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.BUILD_DISCARDER__NUM_TO_KEEP_STR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.BUILD_DISCARDER__NUM_TO_KEEP_STR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBuildDiscarderAccess().getNumToKeepStrEShortParserRuleCall_1_2_0(), semanticObject.getNumToKeepStr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns BuildingTag
	 *     BuildingTag returns BuildingTag
	 *
	 * Constraint:
	 *     {BuildingTag}
	 * </pre>
	 */
	protected void sequence_BuildingTag(ISerializationContext context, BuildingTag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns ChangeRequest
	 *     ChangeRequest returns ChangeRequest
	 *
	 * Constraint:
	 *     (attribute=ATTRIBUTE_TYPE value=EString comparator=COMPARATOR_TYPE?)
	 * </pre>
	 */
	protected void sequence_ChangeRequest(ISerializationContext context, ChangeRequest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns ChangeSet
	 *     ChangeSet returns ChangeSet
	 *
	 * Constraint:
	 *     (pattern=EString comparator=COMPARATOR_TYPE?)
	 * </pre>
	 */
	protected void sequence_ChangeSet(ISerializationContext context, ChangeSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns Changelog
	 *     Changelog returns Changelog
	 *
	 * Constraint:
	 *     expression=EString
	 * </pre>
	 */
	protected void sequence_Changelog(ISerializationContext context, Changelog semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.CHANGELOG__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.CHANGELOG__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChangelogAccess().getExpressionEStringParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns CheckoutToSubdirectory
	 *     CheckoutToSubdirectory returns CheckoutToSubdirectory
	 *
	 * Constraint:
	 *     directory=EString
	 * </pre>
	 */
	protected void sequence_CheckoutToSubdirectory(ISerializationContext context, CheckoutToSubdirectory semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.CHECKOUT_TO_SUBDIRECTORY__DIRECTORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.CHECKOUT_TO_SUBDIRECTORY__DIRECTORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCheckoutToSubdirectoryAccess().getDirectoryEStringParserRuleCall_1_2_0(), semanticObject.getDirectory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter_Directive returns ChoiceParam
	 *     ChoiceParam returns ChoiceParam
	 *
	 * Constraint:
	 *     (name=EString description=EString? choices+=EString choices+=EString*)
	 * </pre>
	 */
	protected void sequence_ChoiceParam(ISerializationContext context, ChoiceParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Command
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.COMMAND__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.COMMAND__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommandAccess().getNameEStringParserRuleCall_2_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns Cron
	 *     Cron returns Cron
	 *
	 * Constraint:
	 *     timer=EString
	 * </pre>
	 */
	protected void sequence_Cron(ISerializationContext context, Cron semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.CRON__TIMER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.CRON__TIMER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCronAccess().getTimerEStringParserRuleCall_1_2_0(), semanticObject.getTimer());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns DisableConcurrentBuilds
	 *     DisableConcurrentBuilds returns DisableConcurrentBuilds
	 *
	 * Constraint:
	 *     abort?='abort'
	 * </pre>
	 */
	protected void sequence_DisableConcurrentBuilds(ISerializationContext context, DisableConcurrentBuilds semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.DISABLE_CONCURRENT_BUILDS__ABORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.DISABLE_CONCURRENT_BUILDS__ABORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDisableConcurrentBuildsAccess().getAbortAbortKeyword_2_1_0(), semanticObject.isAbort());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns DisableRestartFromStage
	 *     DisableRestartFromStage returns DisableRestartFromStage
	 *
	 * Constraint:
	 *     {DisableRestartFromStage}
	 * </pre>
	 */
	protected void sequence_DisableRestartFromStage(ISerializationContext context, DisableRestartFromStage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns DisableResume
	 *     DisableResume returns DisableResume
	 *
	 * Constraint:
	 *     {DisableResume}
	 * </pre>
	 */
	protected void sequence_DisableResume(ISerializationContext context, DisableResume semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Agent returns Docker
	 *     Docker returns Docker
	 *
	 * Constraint:
	 *     (
	 *         image=EString 
	 *         registryUrl=EString? 
	 *         registryCredentialsId=EString? 
	 *         label=EString? 
	 *         customWorkspace=EString? 
	 *         reuseNode=EString? 
	 *         args=EString? 
	 *         alwaysPull?='alwaysPull'?
	 *     )
	 * </pre>
	 */
	protected void sequence_Docker(ISerializationContext context, Docker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Agent returns Dockerfile
	 *     Dockerfile returns Dockerfile
	 *
	 * Constraint:
	 *     (
	 *         filename=EString 
	 *         dir=EString? 
	 *         additionalBuildArgs=EString? 
	 *         registryUrl=EString? 
	 *         registryCredentialsId=EString? 
	 *         label=EString? 
	 *         customWorkspace=EString? 
	 *         reuseNode=EString? 
	 *         args=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_Dockerfile(ISerializationContext context, Dockerfile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Environment returns Environment
	 *
	 * Constraint:
	 *     (key=EString value=EString)
	 * </pre>
	 */
	protected void sequence_Environment(ISerializationContext context, Environment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.ENVIRONMENT__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.ENVIRONMENT__KEY));
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.ENVIRONMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.ENVIRONMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvironmentAccess().getKeyEStringParserRuleCall_1_2_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getEnvironmentAccess().getValueEStringParserRuleCall_1_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns Equals
	 *     Equals returns Equals
	 *
	 * Constraint:
	 *     (expected_val=EString actual_val=EString)
	 * </pre>
	 */
	protected void sequence_Equals(ISerializationContext context, Equals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.EQUALS__EXPECTED_VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.EQUALS__EXPECTED_VAL));
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.EQUALS__ACTUAL_VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.EQUALS__ACTUAL_VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsAccess().getExpected_valEStringParserRuleCall_1_2_0(), semanticObject.getExpected_val());
		feeder.accept(grammarAccess.getEqualsAccess().getActual_valEStringParserRuleCall_1_4_0(), semanticObject.getActual_val());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns Expression
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     expression=EString
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionEStringParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Input returns Input
	 *
	 * Constraint:
	 *     (
	 *         message=EString 
	 *         id=EString? 
	 *         ok=EString? 
	 *         submitter=EString? 
	 *         submitterParameter=EString? 
	 *         parameter_directives+=Parameter_Directive*
	 *     )
	 * </pre>
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Agent returns Label
	 *     Label returns Label
	 *
	 * Constraint:
	 *     label=EString
	 * </pre>
	 */
	protected void sequence_Label(ISerializationContext context, Label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.LABEL__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.LABEL__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelAccess().getLabelEStringParserRuleCall_1_2_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Matrix returns Matrix
	 *
	 * Constraint:
	 *     (
	 *         axis+=Axis+ 
	 *         stages+=Stage+ 
	 *         inputs+=Input* 
	 *         when+=When* 
	 *         environments+=Environment* 
	 *         agents+=Agent* 
	 *         tools+=Tool* 
	 *         post+=Post* 
	 *         stage_options+=StageOption*
	 *     )
	 * </pre>
	 */
	protected void sequence_Matrix(ISerializationContext context, Matrix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns NewContainerPerStage
	 *     NewContainerPerStage returns NewContainerPerStage
	 *
	 * Constraint:
	 *     {NewContainerPerStage}
	 * </pre>
	 */
	protected void sequence_NewContainerPerStage(ISerializationContext context, NewContainerPerStage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Agent returns Node
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (label=EString customWorkspace=EString?)
	 * </pre>
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Agent returns None
	 *     None returns None
	 *
	 * Constraint:
	 *     {None}
	 * </pre>
	 */
	protected void sequence_None(ISerializationContext context, None semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns Not
	 *     Not returns Not
	 *
	 * Constraint:
	 *     when+=When+
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns OverrideIndexTriggers
	 *     OverrideIndexTriggers returns OverrideIndexTriggers
	 *
	 * Constraint:
	 *     override?='override'
	 * </pre>
	 */
	protected void sequence_OverrideIndexTriggers(ISerializationContext context, OverrideIndexTriggers semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.OVERRIDE_INDEX_TRIGGERS__OVERRIDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.OVERRIDE_INDEX_TRIGGERS__OVERRIDE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOverrideIndexTriggersAccess().getOverrideOverrideKeyword_2_1_0(), semanticObject.isOverride());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns ParallelsAlwaysFailFast
	 *     ParallelsAlwaysFailFast returns ParallelsAlwaysFailFast
	 *
	 * Constraint:
	 *     {ParallelsAlwaysFailFast}
	 * </pre>
	 */
	protected void sequence_ParallelsAlwaysFailFast(ISerializationContext context, ParallelsAlwaysFailFast semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter_Directive returns PasswordParam
	 *     PasswordParam returns PasswordParam
	 *
	 * Constraint:
	 *     (name=EString description=EString? defaultValue=EString)
	 * </pre>
	 */
	protected void sequence_PasswordParam(ISerializationContext context, PasswordParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pipeline returns Pipeline
	 *
	 * Constraint:
	 *     (
	 *         agents+=Agent+ 
	 *         options+=Option* 
	 *         triggers+=Trigger* 
	 *         parameter_directives+=Parameter_Directive* 
	 *         environments+=Environment* 
	 *         tools+=Tool* 
	 *         stages+=Stage+ 
	 *         post+=Post*
	 *     )
	 * </pre>
	 */
	protected void sequence_Pipeline(ISerializationContext context, Pipeline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns PollSCM
	 *     PollSCM returns PollSCM
	 *
	 * Constraint:
	 *     timer=EString
	 * </pre>
	 */
	protected void sequence_PollSCM(ISerializationContext context, PollSCM semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.POLL_SCM__TIMER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.POLL_SCM__TIMER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPollSCMAccess().getTimerEStringParserRuleCall_1_2_0(), semanticObject.getTimer());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Post returns Post
	 *
	 * Constraint:
	 *     (condition=POST_TYPE steps+=Step+)
	 * </pre>
	 */
	protected void sequence_Post(ISerializationContext context, Post semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns PreserveStashes
	 *     PreserveStashes returns PreserveStashes
	 *
	 * Constraint:
	 *     buildCount=EString?
	 * </pre>
	 */
	protected void sequence_PreserveStashes(ISerializationContext context, PreserveStashes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns QuietPeriod
	 *     QuietPeriod returns QuietPeriod
	 *
	 * Constraint:
	 *     period=EShort
	 * </pre>
	 */
	protected void sequence_QuietPeriod(ISerializationContext context, QuietPeriod semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.QUIET_PERIOD__PERIOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.QUIET_PERIOD__PERIOD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQuietPeriodAccess().getPeriodEShortParserRuleCall_2_2_0(), semanticObject.getPeriod());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns Retry
	 *     StageOption returns Retry
	 *     Retry returns Retry
	 *
	 * Constraint:
	 *     retries=EShort
	 * </pre>
	 */
	protected void sequence_Retry(ISerializationContext context, Retry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.RETRY__RETRIES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.RETRY__RETRIES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRetryAccess().getRetriesEShortParserRuleCall_1_2_0(), semanticObject.getRetries());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns SkipDefaultCheckout
	 *     StageOption returns SkipDefaultCheckout
	 *     SkipDefaultCheckout returns SkipDefaultCheckout
	 *
	 * Constraint:
	 *     {SkipDefaultCheckout}
	 * </pre>
	 */
	protected void sequence_SkipDefaultCheckout(ISerializationContext context, SkipDefaultCheckout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns SkipStagesAfterUnstable
	 *     SkipStagesAfterUnstable returns SkipStagesAfterUnstable
	 *
	 * Constraint:
	 *     {SkipStagesAfterUnstable}
	 * </pre>
	 */
	protected void sequence_SkipStagesAfterUnstable(ISerializationContext context, SkipStagesAfterUnstable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Stage returns Stage
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         parallel?='parallel'? 
	 *         failFast?='failFast'? 
	 *         stages+=Stage* 
	 *         agents+=Agent* 
	 *         steps+=Step* 
	 *         environments+=Environment* 
	 *         inputs+=Input* 
	 *         when+=When* 
	 *         stage_options+=StageOption* 
	 *         matrix=Matrix?
	 *     )
	 * </pre>
	 */
	protected void sequence_Stage(ISerializationContext context, Stage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step_Parameter returns Step_Parameter
	 *
	 * Constraint:
	 *     parameter=EString
	 * </pre>
	 */
	protected void sequence_Step_Parameter(ISerializationContext context, Step_Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.STEP_PARAMETER__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.STEP_PARAMETER__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStep_ParameterAccess().getParameterEStringParserRuleCall_1_2_0(), semanticObject.getParameter());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns Step
	 *
	 * Constraint:
	 *     (commands=Command step_parameters+=Step_Parameter*)
	 * </pre>
	 */
	protected void sequence_Step(ISerializationContext context, Step semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter_Directive returns StringParam
	 *     StringParam returns StringParam
	 *
	 * Constraint:
	 *     (name=EString description=EString? defaultValue=EString)
	 * </pre>
	 */
	protected void sequence_StringParam(ISerializationContext context, StringParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns Tag
	 *     Tag returns Tag
	 *
	 * Constraint:
	 *     (pattern=EString comparator=COMPARATOR_TYPE?)
	 * </pre>
	 */
	protected void sequence_Tag(ISerializationContext context, Tag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter_Directive returns TextParam
	 *     TextParam returns TextParam
	 *
	 * Constraint:
	 *     (name=EString description=EString? defaultValue=EString)
	 * </pre>
	 */
	protected void sequence_TextParam(ISerializationContext context, TextParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns Timeout
	 *     StageOption returns Timeout
	 *     Timeout returns Timeout
	 *
	 * Constraint:
	 *     (time=EShort unit=EString)
	 * </pre>
	 */
	protected void sequence_Timeout(ISerializationContext context, Timeout semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.TIMEOUT__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.TIMEOUT__TIME));
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.TIMEOUT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.TIMEOUT__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeoutAccess().getTimeEShortParserRuleCall_1_2_0(), semanticObject.getTime());
		feeder.accept(grammarAccess.getTimeoutAccess().getUnitEStringParserRuleCall_1_4_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Option returns Timestamps
	 *     StageOption returns Timestamps
	 *     Timestamps returns Timestamps
	 *
	 * Constraint:
	 *     {Timestamps}
	 * </pre>
	 */
	protected void sequence_Timestamps(ISerializationContext context, Timestamps semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Tool returns Tool
	 *
	 * Constraint:
	 *     (tool=TOOL_TYPE tool_name=EString)
	 * </pre>
	 */
	protected void sequence_Tool(ISerializationContext context, Tool semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.TOOL__TOOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.TOOL__TOOL));
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.TOOL__TOOL_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.TOOL__TOOL_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getToolAccess().getToolTOOL_TYPEEnumRuleCall_1_2_0(), semanticObject.getTool());
		feeder.accept(grammarAccess.getToolAccess().getTool_nameEStringParserRuleCall_1_4_0(), semanticObject.getTool_name());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns TriggeredBy
	 *     TriggeredBy returns TriggeredBy
	 *
	 * Constraint:
	 *     parameter=EString
	 * </pre>
	 */
	protected void sequence_TriggeredBy(ISerializationContext context, TriggeredBy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.TRIGGERED_BY__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.TRIGGERED_BY__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTriggeredByAccess().getParameterEStringParserRuleCall_1_2_0(), semanticObject.getParameter());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns Upstream
	 *     Upstream returns Upstream
	 *
	 * Constraint:
	 *     (jobs+=EString jobs+=EString* threshold=EString)
	 * </pre>
	 */
	protected void sequence_Upstream(ISerializationContext context, Upstream semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     When returns When_Env
	 *     When_Env returns When_Env
	 *
	 * Constraint:
	 *     (name=EString value=EString)
	 * </pre>
	 */
	protected void sequence_When_Env(ISerializationContext context, When_Env semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.WHEN_ENV__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.WHEN_ENV__NAME));
			if (transientValues.isValueTransient(semanticObject, Jenkins_metamodelPackage.Literals.WHEN_ENV__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Jenkins_metamodelPackage.Literals.WHEN_ENV__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhen_EnvAccess().getNameEStringParserRuleCall_1_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getWhen_EnvAccess().getValueEStringParserRuleCall_1_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}

/*
 * generated by Xtext 2.34.0
 */
package org.xtext.example.cicd.ui.quickfix;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.eclipse.jface.text.BadLocationException;
import org.eclipse.xtext.ui.editor.model.IXtextDocument;
import org.eclipse.xtext.ui.editor.model.edit.IModification;
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext;
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider;
import org.eclipse.xtext.ui.editor.quickfix.Fix;
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor;
import org.eclipse.xtext.validation.Issue;
import org.xtext.example.cicd.validation.CICDValidator;

/**
 * Custom quickfixes.
 *
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
public class CICDQuickfixProvider extends DefaultQuickfixProvider {
	
	@Fix(CICDValidator.INVALID_CRON_SYNTAX_ERRORCODE)
    public void fixCronSyntax(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Correct Cron Syntax", "Correct the cron syntax.", null, new IModification() {
        	public void apply(IModificationContext context) throws BadLocationException {
	        	IXtextDocument xtextDocument = context.getXtextDocument();
	        	xtextDocument.replace(issue.getOffset(), issue.getLength(), "\"*/1 * * * *\"");
        	}
        });
    }

    @Fix(CICDValidator.INVALID_CONDITION_PATTERN_ERRORCODE)
    public void fixConditionPattern(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Correct Condition Pattern", "Correct the condition pattern.", null, new IModification() {
        	public void apply(IModificationContext context) throws BadLocationException {
	        	IXtextDocument xtextDocument = context.getXtextDocument();
	        	Integer offset = issue.getOffset();
	        	Integer length = issue.getLength();
	            String condition = xtextDocument.get(offset, length);
	            xtextDocument.replace(offset, length, "\"${{ " + condition + " }}\"");
        	}
        });
    }

    @Fix(CICDValidator.INVALID_BOOLEAN_DEFAULT_ERRORCODE)
    public void fixBooleanDefault(Issue issue, IssueResolutionAcceptor acceptor) {
    	acceptor.accept(issue, "Set Default to 'true'", "Set the default value to 'true'.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
                IXtextDocument xtextDocument = context.getXtextDocument();
                xtextDocument.replace(issue.getOffset(), issue.getLength(), "\"true\"");
            }
        });
    }
    
    @Fix(CICDValidator.INVALID_BOOLEAN_DEFAULT_ERRORCODE)
    public void fixBooleanDefault2(Issue issue, IssueResolutionAcceptor acceptor) {
    	acceptor.accept(issue, "Set Default to 'false'", "Set the default value to 'false'.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
                IXtextDocument xtextDocument = context.getXtextDocument();
                xtextDocument.replace(issue.getOffset(), issue.getLength(), "\"false\"");
            }
        });
    }
    
    @Fix(CICDValidator.DUPLICATE_JOB_NAME_ERRORCODE)
	public void fixDuplicateJobName(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Rename Job", "Rename the job to ensure uniqueness.", null, new IModification() {
        	public void apply(IModificationContext context) throws BadLocationException {
        		IXtextDocument xtextDocument = context.getXtextDocument();
                Integer offset = issue.getOffset();
                Integer length = issue.getLength();
                String originalName = xtextDocument.get(offset, length);
                int randomInt = (int) (Math.random() * 100);
                
                if(originalName.contains("\"")) {
                    int firstQuoteIndex = originalName.indexOf("\"");
                    int lastQuoteIndex = originalName.lastIndexOf("\"");
                    
                    if (firstQuoteIndex != -1 && lastQuoteIndex != -1 && firstQuoteIndex != lastQuoteIndex) {
                        String newName = originalName.substring(0, lastQuoteIndex) + randomInt + originalName.substring(lastQuoteIndex);
                        xtextDocument.replace(offset, length, newName);
                    } else {
                        
                    }
                } else {
                    String newName = originalName + randomInt;
                    xtextDocument.replace(offset, length, newName);
                }
            }
        });
    }

    @Fix(CICDValidator.REQUIRED_JOB_NOT_EXIST_ERRORCODE)
    public void fixRequiredJob(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Fix requireJobs not found", "Change requireJobs to reference an existing job.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
                IXtextDocument xtextDocument = context.getXtextDocument();
                String documentContent = xtextDocument.get();
                List<String> jobNames = extractJobNames(documentContent);
                Integer offset = issue.getOffset();

                String currentJobName = extractCurrentJobName(documentContent, offset);
                Collections.shuffle(jobNames);
                String newJobName = jobNames.stream()
                                            .filter(name -> !name.equals(currentJobName))
                                            .findFirst()
                                            .orElse(null);
                
                if (newJobName != null) {
                    xtextDocument.replace(offset, issue.getLength(), newJobName);
                }
                else {
                	int lineStart = getLineStart(documentContent, offset);
                    int lineEnd = getLineEnd(documentContent, offset);
                    xtextDocument.replace(lineStart, lineEnd - lineStart, "");
                }
            }
        });
    }
    
    
    
    @Fix(CICDValidator.MANDATORY_JOB_NAME_EMPTY_ERRORCODE)
    public void fixEmptyJobName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty job name", acceptor, "\"New Job Name\"");
    }

    @Fix(CICDValidator.MANDATORY_OUTPUT_NAME_EMPTY_ERRORCODE)
    public void fixEmptyOutputName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty output name", acceptor, "\"New Output Name\"");
    }

    @Fix(CICDValidator.MANDATORY_OUTPUT_VALUE_EMPTY_ERRORCODE)
    public void fixEmptyOutputValue(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Output Value", acceptor, "\"New Output Value\"");
    }

    @Fix(CICDValidator.MANDATORY_DOCKER_IMAGE_EMPTY_ERRORCODE)
    public void fixEmptyDockerImage(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Docker Image", acceptor, "\"New Docker Image\"");
    }

    @Fix(CICDValidator.MANDATORY_COMMAND_NAME_EMPTY_ERRORCODE)
    public void fixEmptyCommandName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Command Name", acceptor, "\"New Command Name\"");
    }

    @Fix(CICDValidator.MANDATORY_ENVIRONMENT_KEY_EMPTY_ERRORCODE)
    public void fixEmptyEnvironmentKey(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty nvironment Key", acceptor, "\"New Environment Key\"");
    }

    @Fix(CICDValidator.MANDATORY_ENVIRONMENT_VALUE_EMPTY_ERRORCODE)
    public void fixEmptyEnvironmentValue(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Environment Value", acceptor, "\"New Environment Value\"");
    }

    @Fix(CICDValidator.MANDATORY_PARAMETER_EMPTY_ERRORCODE)
    public void fixEmptyParameter(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Parameter Value", acceptor, "\"New Parameter Value\"");
    }

    @Fix(CICDValidator.MANDATORY_MATRIX_CONFIG_NAME_EMPTY_ERRORCODE)
    public void fixEmptyMatrixConfigName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty MatrixConfig Name", acceptor, "\"New MatrixConfig Name\"");
    }

    @Fix(CICDValidator.MANDATORY_MATRIX_CONFIG_VALUES_EMPTY_ERRORCODE)
    public void fixEmptyMatrixConfigValues(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty MatrixConfig Value", acceptor, "\"New MatrixConfig Value\"");
    }

    @Fix(CICDValidator.MANDATORY_INPUT_NAME_EMPTY_ERRORCODE)
    public void fixEmptyInputName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Input Name", acceptor, "\"New Input Name\"");
    }

    @Fix(CICDValidator.MANDATORY_SCHEDULE_TRIGGER_TIMER_EMPTY_ERRORCODE)
    public void fixEmptyScheduleTriggerTimer(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty ScheduleTrigger timer", acceptor, "\"*/1 * * * *\"");
    }

    @Fix(CICDValidator.MANDATORY_IF_STEP_CONDITION_EMPTY_ERRORCODE)
    public void fixEmptyIfStepCondition(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty IfStep Condition", acceptor, "\"${{ NewCondition }}\"");
    }
    
    /*
     * Auxiliary Methods
     */
    
    
    private void fixEmptyString(Issue issue, String label, IssueResolutionAcceptor acceptor, String suggestion) {
        acceptor.accept(issue, label, suggestion, null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
                IXtextDocument xtextDocument = context.getXtextDocument();
                String newValue = suggestion; 
                xtextDocument.replace(issue.getOffset(), issue.getLength(), newValue);
            }
        });
    }

    private List<String> extractJobNames(String documentContent) {
        List<String> jobNames = new ArrayList<>();
        String jobKeyword = "Job";
        String nameKeyword = "name ";
        String newline = "\n";
        
        int jobIndex = documentContent.lastIndexOf(jobKeyword);
        while (jobIndex >= 0) {
            int lineStart = documentContent.lastIndexOf(newline, jobIndex) + 1;
            int lineEnd = documentContent.indexOf(newline, jobIndex);
            
            String line = documentContent.substring(lineStart, lineEnd);
            if (line.trim().startsWith(jobKeyword)) {
                int nextLineStart = lineEnd + 1;
                int nextLineEnd = documentContent.indexOf(newline, nextLineStart);
                String nextLine = documentContent.substring(nextLineStart, nextLineEnd);
                if (nextLine.contains(nameKeyword)) {
                    int nameIndex = nextLine.indexOf(nameKeyword);
                    String currentJobName = nextLine.substring(nameIndex + nameKeyword.length()).trim();
                    jobNames.add(currentJobName);
                }
            }
            jobIndex = documentContent.lastIndexOf(jobKeyword, jobIndex - 1);
        }
        
        return jobNames;
    }


    private String extractCurrentJobName(String documentContent, int offset) {
        String nameKeyword = "name ";
        int nameIndex = documentContent.lastIndexOf(nameKeyword, offset);
        if (nameIndex >= 0) {
            int lineStart = documentContent.lastIndexOf("\n", nameIndex) + 1;
            int lineEnd = documentContent.indexOf("\n", nameIndex);
            String line = documentContent.substring(lineStart, lineEnd);
            String currentJobName = line.trim();
            if (currentJobName.startsWith(nameKeyword)) {
                currentJobName = currentJobName.substring(nameKeyword.length()).trim();
                return currentJobName;
            }
        }
        return null;
    }

    
    private int getLineStart(String documentContent, int offset) {
        int lineStart = offset;
        while (lineStart > 0 && documentContent.charAt(lineStart - 1) != '\n') {
            lineStart--;
        }
        return lineStart;
    }

    private int getLineEnd(String documentContent, int offset) {
        int lineEnd = offset;
        while (lineEnd < documentContent.length() && documentContent.charAt(lineEnd) != '\n') {
            lineEnd++;
        }
        return lineEnd + 1; // Include the newline character
    }
}

/*
 * generated by Xtext 2.34.0
 */
package org.xtext.example.gha.ui.quickfix;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.eclipse.jface.text.BadLocationException;
import org.eclipse.xtext.ui.editor.model.IXtextDocument;
import org.eclipse.xtext.ui.editor.model.edit.IModification;
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext;
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider;
import org.eclipse.xtext.ui.editor.quickfix.Fix;
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor;
import org.eclipse.xtext.validation.Issue;
import org.xtext.example.gha.validation.GHAValidator;

/**
 * Custom quickfixes.
 *
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
public class GHAQuickfixProvider extends DefaultQuickfixProvider {
	
	@Fix(GHAValidator.DUPLICATE_PIPELINE_PERMISSION_ERRORCODE)
    public void fixDuplicatePipelinePermission(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Remove Duplicate Pipeline Permission", "Remove the duplicate pipeline permission.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                int offset = issue.getOffset();
                String documentContent = xtextDocument.get();
                int lineStart = getLineStart(documentContent, offset);
                int lineEnd = getLineEnd(documentContent, offset);
                xtextDocument.replace(lineStart, lineEnd - lineStart, "");
            }
        });
    }

    @Fix(GHAValidator.DUPLICATE_JOB_PERMISSION_ERRORCODE)
    public void fixDuplicateJobPermission(Issue issue, IssueResolutionAcceptor acceptor) {
    	acceptor.accept(issue, "Remove Duplicate Job Permission", "Remove the duplicate job permission.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                int offset = issue.getOffset();
                String documentContent = xtextDocument.get();
                int lineStart = getLineStart(documentContent, offset);
                int lineEnd = getLineEnd(documentContent, offset);
                xtextDocument.replace(lineStart, lineEnd - lineStart, "");
            }
        });
    }

    @Fix(GHAValidator.MULTIPLE_TRIGGER_TYPES_ERRORCODE)
    public void fixMultipleTriggerTypes(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Remove Multiple Trigger Types", "Remove the extra trigger type.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                int offset = issue.getOffset();
                String documentContent = xtextDocument.get();
                int lineStart = getLineStart(documentContent, offset);
                int lineEnd = getLineEnd(documentContent, offset);
                xtextDocument.replace(lineStart, lineEnd - lineStart, "");
            }
        });
    }
	
    @Fix(GHAValidator.CONFLICTING_PERMISSIONS_ERRORCODE)
    public void fixConflictingPermissions(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Remove Conflicting Permissions", "Remove the conflicting permissions.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
                IXtextDocument xtextDocument = context.getXtextDocument();
                xtextDocument.replace(issue.getOffset(), issue.getLength(), "");
            }
        });
    }

    @Fix(GHAValidator.LABELS_AND_GROUP_NULL_ERRORCODE)
    public void fixLabelsAndGroupNotNull(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Provide Labels or Group", "Provide labels or group for runs on.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                xtextDocument.replace(issue.getOffset(), issue.getLength(), "");
            }
        });
    }

    @Fix(GHAValidator.LABELS_AND_GROUP_EMPTY_ERRORCODE)
    public void fixLabelsAndGroupNotEmpty(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Provide Non-empty Group", "Provide non-empty group for runs on.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                xtextDocument.replace(issue.getOffset(), issue.getLength(), "\"my-group\"");
            }
        });
    }
    
    @Fix(GHAValidator.LABELS_AND_GROUP_EMPTY_ERRORCODE)
    public void fixLabelsAndGroupNotEmpty2(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Provide Non-empty Labels", "Provide non-empty labels for runs on.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                xtextDocument.replace(issue.getOffset(), issue.getLength(), "\"my-label_1\"");
            }
        });
    }
    
    @Fix(GHAValidator.ARGS_AND_ENTRYPOINT_NULL_ERRORCODE)
    public void fixArgsAndEntrypointNotNull(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Initialize Args and Entrypoint", "Initialize the args and entrypoint.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                xtextDocument.replace(issue.getOffset(), issue.getLength(), "");
            }
        });
    }

    @Fix(GHAValidator.ARGS_AND_ENTRYPOINT_EMPTY_ERRORCODE)
    public void fixArgsAndEntrypointNotEmpty(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Provide Non-empty Args", "Provide values for args.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                xtextDocument.replace(issue.getOffset(), issue.getLength(), "\"arg_1\"");
            }
        });
    }
    
    @Fix(GHAValidator.ARGS_AND_ENTRYPOINT_EMPTY_ERRORCODE)
    public void fixArgsAndEntrypointNotEmpty2(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Provide Non-empty Entrypoint", "Provide values for entrypoint.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                xtextDocument.replace(issue.getOffset(), issue.getLength(), "\"entrypoint 012\"");
            }
        });
    }
    
    @Fix(GHAValidator.INVALID_CRON_SYNTAX_ERRORCODE)
    public void fixInvalidCronSyntax(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Correct Cron Syntax", "Correct the cron syntax.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                xtextDocument.replace(issue.getOffset(), issue.getLength(), "\"*/1 * * * *\"");
            }
        });
    }
    

    @Fix(GHAValidator.MISSING_JOBS_ERRORCODE)
    public void fixMissingJobs(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Refer existing job", "Refer to an existing job.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                String documentContent = xtextDocument.get();
                List<String> jobNames = extractJobNames(documentContent);
                Integer offset = issue.getOffset();

                String currentJobName = extractCurrentJobName(documentContent, offset);
                Collections.shuffle(jobNames);
                String newJobName = jobNames.stream()
                                            .filter(name -> !name.equals(currentJobName))
                                            .findAny()
                                            .orElse(null);
                if (newJobName != null) {
                    xtextDocument.replace(offset, issue.getLength(), newJobName);
                } else {
                    int lineStart = getLineStart(documentContent, offset);
                    int lineEnd = getLineEnd(documentContent, offset);
                    xtextDocument.replace(lineStart, lineEnd - lineStart, "");
                }
            }
        });
    }

    @Fix(GHAValidator.DUPLICATE_JOB_NAME_ERRORCODE)
    public void fixDuplicateJobName(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Rename Job", "Rename the job to ensure uniqueness.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                Integer offset = issue.getOffset();
                Integer length = issue.getLength();
                String originalName = xtextDocument.get(offset, length);
                int randomInt = (int) (Math.random() * 100);
                String newName = originalName + randomInt;
                xtextDocument.replace(offset, length, newName);
            }
        });
    }


    @Fix(GHAValidator.INVALID_CONDITION_PATTERN_ERRORCODE)
    public void fixInvalidConditionPattern(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Correct Condition Pattern", "Correct the condition pattern.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
	        	Integer offset = issue.getOffset();
	        	Integer length = issue.getLength();
	            String condition = xtextDocument.get(offset, length);
	            xtextDocument.replace(offset, length, "\"${{ " + condition + " }}\"");
            }
        });
    }
	
	
    @Fix(GHAValidator.MANDATORY_CREDENTIALS_USERNAME_EMPTY_ERRORCODE)
    public void fixEmptyCredentialsUsername(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Credentials Username", acceptor, "\"New Username\"");
    }

    @Fix(GHAValidator.MANDATORY_CREDENTIALS_PASSWORD_EMPTY_ERRORCODE)
    public void fixEmptyCredentialsPassword(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Credentials Password", acceptor, "\"New Password\"");
    }

    @Fix(GHAValidator.MANDATORY_JOB_NAME_EMPTY_ERRORCODE)
    public void fixEmptyJobName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Job Name", acceptor, "\"New Job Name\"");
    }
    
    @Fix(GHAValidator.MANDATORY_DOCKER_IMAGE_EMPTY_ERRORCODE)
    public void fixEmptyDockerImage(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Docker Image", acceptor, "\"New Docker Image\"");
    }

    @Fix(GHAValidator.MANDATORY_DOCKER_USES_EMPTY_ERRORCODE)
    public void fixEmptyDockerUses(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Docker Uses", acceptor, "\"New Docker Uses\"");
    }

    @Fix(GHAValidator.MANDATORY_SERVICE_NAME_EMPTY_ERRORCODE)
    public void fixEmptyStepName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Step Name", acceptor, "\"New Step Name\"");
    }

    @Fix(GHAValidator.MANDATORY_COMMAND_NAME_EMPTY_ERRORCODE)
    public void fixEmptyCommandName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Command Name", acceptor, "\"New Command Name\"");
    }

    @Fix(GHAValidator.MANDATORY_PARAMETER_NAME_EMPTY_ERRORCODE)
    public void fixEmptyParameterName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Parameter Name", acceptor, "\"New Parameter Name\"");
    }

    @Fix(GHAValidator.MANDATORY_NEED_JOBS_EMPTY_ERRORCODE)
    public void fixEmptyNeedJobs(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Need Jobs", acceptor, "\"New Need Jobs\"");
    }

    @Fix(GHAValidator.MANDATORY_ARTIFACT_PATHS_EMPTY_ERRORCODE)
    public void fixEmptyArtifactPaths(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Artifact Paths", acceptor, "\"New Artifact Paths\"");
    }

    @Fix(GHAValidator.MANDATORY_ARTIFACT_USES_EMPTY_ERRORCODE)
    public void fixEmptyArtifactUses(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Artifact Uses", acceptor, "\"New Artifact Uses\"");
    }

    @Fix(GHAValidator.MANDATORY_RESTORECACHE_PATHS_EMPTY_ERRORCODE)
    public void fixEmptyRestoreCachePaths(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty RestoreCache Paths", acceptor, "\"New RestoreCache Paths\"");
    }

    @Fix(GHAValidator.MANDATORY_RESTORECACHE_USES_EMPTY_ERRORCODE)
    public void fixEmptyRestoreCacheUses(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty RestoreCache Uses", acceptor, "\"New RestoreCache Uses\"");
    }

    @Fix(GHAValidator.MANDATORY_RESTORECACHE_KEY_EMPTY_ERRORCODE)
    public void fixEmptyRestoreCacheKey(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty RestoreCache Key", acceptor, "\"New RestoreCache Key\"");
    }

    @Fix(GHAValidator.MANDATORY_SAVECACHE_PATHS_EMPTY_ERRORCODE)
    public void fixEmptySaveCachePaths(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty SaveCache Paths", acceptor, "\"New SaveCache Paths\"");
    }

    @Fix(GHAValidator.MANDATORY_SAVECACHE_USES_EMPTY_ERRORCODE)
    public void fixEmptySaveCacheUses(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty SaveCache Uses", acceptor, "\"New SaveCache Uses\"");
    }

    @Fix(GHAValidator.MANDATORY_SAVECACHE_KEY_EMPTY_ERRORCODE)
    public void fixEmptySaveCacheKey(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty SaveCache Key", acceptor, "\"New SaveCache Key\"");
    }

    @Fix(GHAValidator.MANDATORY_ENVIRONMENT_NAME_EMPTY_ERRORCODE)
    public void fixEmptyEnvironmentName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Environment Name", acceptor, "\"New Environment Name\"");
    }

    @Fix(GHAValidator.MANDATORY_ACTION_USES_EMPTY_ERRORCODE)
    public void fixEmptyActionUses(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Action Uses", acceptor, "\"New Action Uses\"");
    }

    @Fix(GHAValidator.MANDATORY_OUTPUT_NAME_EMPTY_ERRORCODE)
    public void fixEmptyOutputName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Output Name", acceptor, "\"New Output Name\"");
    }

    @Fix(GHAValidator.MANDATORY_OUTPUT_VALUE_EMPTY_ERRORCODE)
    public void fixEmptyOutputValue(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Output Value", acceptor, "\"New Output Value\"");
    }
    
    @Fix(GHAValidator.MANDATORY_SCHEDULETRIGGER_CRON_EMPTY_ERRORCODE)
    public void fixEmptyScheduleTriggerCron(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty ScheduleTrigger Cron", acceptor, "\"New ScheduleTrigger Cron\"");
    }

    @Fix(GHAValidator.MANDATORY_SECRET_KEY_EMPTY_ERRORCODE)
    public void fixEmptySecretKey(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Secret Key", acceptor, "\"New Secret Key\"");
    }

    @Fix(GHAValidator.MANDATORY_SECRET_VALUE_EMPTY_ERRORCODE)
    public void fixEmptySecretValue(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Secret Value", acceptor, "\"New Secret Value\"");
    }

    @Fix(GHAValidator.MANDATORY_SECRET_NAME_EMPTY_ERRORCODE)
    public void fixEmptySecretName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Secret Name", acceptor, "\"New Secret Name\"");
    }

    @Fix(GHAValidator.MANDATORY_PERMISSION_TYPE_EMPTY_ERRORCODE)
    public void fixEmptyPermissionType(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Permission Type", acceptor, "\"New Permission Type\"");
    }

    @Fix(GHAValidator.MANDATORY_ENV_KEY_EMPTY_ERRORCODE)
    public void fixEmptyEnvKey(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Env Key", acceptor, "\"New Env Key\"");
    }

    @Fix(GHAValidator.MANDATORY_ENV_VALUE_EMPTY_ERRORCODE)
    public void fixEmptyEnvValue(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Env Value", acceptor, "\"New Env Value\"");
    }

    @Fix(GHAValidator.MANDATORY_CONCURRENCY_GROUP_EMPTY_ERRORCODE)
    public void fixEmptyConcurrencyGroup(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Concurrency Group", acceptor, "\"New Concurrency Group\"");
    }

    @Fix(GHAValidator.MANDATORY_IF_CONDITION_EMPTY_ERRORCODE)
    public void fixEmptyIfCondition(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty If Condition", acceptor, "\"New If Condition\"");
    }

    @Fix(GHAValidator.MANDATORY_MATRIXCONFIG_KEY_EMPTY_ERRORCODE)
    public void fixEmptyMatrixConfigKey(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty MatrixConfig Key", acceptor, "\"New MatrixConfig Key\"");
    }

    @Fix(GHAValidator.MANDATORY_MATRIXCONFIG_VALUES_EMPTY_ERRORCODE)
    public void fixEmptyMatrixConfigValues(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty MatrixConfig Values", acceptor, "\"New MatrixConfig Values\"");
    }

    @Fix(GHAValidator.MANDATORY_INPUTPARAMS_KEY_EMPTY_ERRORCODE)
    public void fixEmptyInputParamsKey(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty InputParams Key", acceptor, "\"New InputParams Key\"");
    }

    @Fix(GHAValidator.MANDATORY_INPUTPARAMS_VALUE_EMPTY_ERRORCODE)
    public void fixEmptyInputParamsValue(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty InputParams Value", acceptor, "\"New InputParams Value\"");
    }

    @Fix(GHAValidator.MANDATORY_DEFAULTSETTING_SHELL_EMPTY_ERRORCODE)
    public void fixEmptyDefaultSettingShell(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty DefaultSetting Shell", acceptor, "\"New DefaultSetting Shell\"");
    }

    @Fix(GHAValidator.MANDATORY_DEFAULTSETTING_WORKINGDIRECTORY_EMPTY_ERRORCODE)
    public void fixEmptyDefaultSettingWorkingDirectory(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty DefaultSetting WorkingDirectory", acceptor, "\"New DefaultSetting WorkingDirectory\"");
    }

    @Fix(GHAValidator.MANDATORY_PATH_NAME_EMPTY_ERRORCODE)
    public void fixEmptyPathName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Path Name", acceptor, "\"New Path Name\"");
    }

    @Fix(GHAValidator.MANDATORY_BRANCH_NAME_EMPTY_ERRORCODE)
    public void fixEmptyBranchName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Branch Name", acceptor, "\"New Branch Name\"");
    }

    @Fix(GHAValidator.MANDATORY_TAG_NAME_EMPTY_ERRORCODE)
    public void fixEmptyTagName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Tag Name", acceptor, "\"New Tag Name\"");
    }

    @Fix(GHAValidator.MANDATORY_WORKFLOWRUNTRIGGER_WORKFLOW_EMPTY_ERRORCODE)
    public void fixEmptyWorkflowRunTriggerWorkflow(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty WorkflowRunTrigger Workflow", acceptor, "\"New WorkflowRunTrigger Workflow\"");
    }

    @Fix(GHAValidator.MANDATORY_WORKFLOWRUNTRIGGER_TYPE_EMPTY_ERRORCODE)
    public void fixEmptyWorkflowRunTriggerType(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty WorkflowRunTrigger Type", acceptor, "\"New WorkflowRunTrigger Type\"");
    }

    @Fix(GHAValidator.MANDATORY_CONTAINER_IMAGE_EMPTY_ERRORCODE)
    public void fixEmptyContainerImage(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Container Image", acceptor, "\"New Container Image\"");
    }

    @Fix(GHAValidator.MANDATORY_INPUT_NAME_EMPTY_ERRORCODE)
    public void fixEmptyInputName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Input Name", acceptor, "\"New Input Name\"");
    }

    
    /*
     * Auxiliary Methods
     */
    
	private void fixEmptyString(Issue issue, String label, IssueResolutionAcceptor acceptor, String suggestion) {
        acceptor.accept(issue, label, suggestion, null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
                IXtextDocument xtextDocument = context.getXtextDocument();
                String newValue = suggestion; 
                xtextDocument.replace(issue.getOffset(), issue.getLength(), newValue);
            }
        });
    }
	
	private String extractCurrentJobName(String documentContent, int offset) {
        String nameKeyword = "name ";
        int nameIndex = documentContent.lastIndexOf(nameKeyword, offset);
        if (nameIndex >= 0) {
            int lineStart = documentContent.lastIndexOf("\n", nameIndex) + 1;
            int lineEnd = documentContent.indexOf("\n", nameIndex);
            String line = documentContent.substring(lineStart, lineEnd);
            String currentJobName = line.trim();
            if (currentJobName.startsWith(nameKeyword)) {
                currentJobName = currentJobName.substring(nameKeyword.length()).trim();
                return currentJobName;
            }
        }
        return null;
    }
	
	private List<String> extractJobNames(String documentContent) {
        List<String> jobNames = new ArrayList<>();
        String jobKeyword = "Job";
        String nameKeyword = "name ";
        String newline = "\n";
        
        int jobIndex = documentContent.lastIndexOf(jobKeyword);
        while (jobIndex >= 0) {
            int lineStart = documentContent.lastIndexOf(newline, jobIndex) + 1;
            int lineEnd = documentContent.indexOf(newline, jobIndex);
            
            String line = documentContent.substring(lineStart, lineEnd);
            if (line.trim().startsWith(jobKeyword)) {
                int nextLineStart = lineEnd + 1;
                int nextLineEnd = documentContent.indexOf(newline, nextLineStart);
                String nextLine = documentContent.substring(nextLineStart, nextLineEnd);
                if (nextLine.contains(nameKeyword)) {
                    int nameIndex = nextLine.indexOf(nameKeyword);
                    jobNames.add(nextLine.substring(nameIndex + nameKeyword.length()).trim());
                }
            }
            jobIndex = documentContent.lastIndexOf(jobKeyword, jobIndex - 1);
        }
        
        return jobNames;
    }
	
	
	private int getLineStart(String documentContent, int offset) {
        int lineStart = offset;
        while (lineStart > 0 && documentContent.charAt(lineStart - 1) != '\n') {
            lineStart--;
        }
        return lineStart;
    }


    private int getLineEnd(String documentContent, int offset) {
        int lineEnd = offset;
        while (lineEnd < documentContent.length() && documentContent.charAt(lineEnd) != '\n') {
            lineEnd++;
        }
        return lineEnd + 1; // Include the newline character
    }
}

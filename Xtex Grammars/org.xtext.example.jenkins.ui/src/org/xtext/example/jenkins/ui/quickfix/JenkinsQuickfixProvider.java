/*
 * generated by Xtext 2.34.0
 */
package org.xtext.example.jenkins.ui.quickfix;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.eclipse.jface.text.BadLocationException;
import org.eclipse.xtext.ui.editor.model.IXtextDocument;
import org.eclipse.xtext.ui.editor.model.edit.IModification;
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext;
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider;
import org.eclipse.xtext.ui.editor.quickfix.Fix;
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor;
import org.eclipse.xtext.validation.Issue;
import org.xtext.example.jenkins.validation.JenkinsValidator;

/**
 * Custom quickfixes.
 *
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
public class JenkinsQuickfixProvider extends DefaultQuickfixProvider {
	
	@Fix(JenkinsValidator.INVALID_STAGE_DEFINITION_ERRORCODE)
    public void fixInvalidStageDefinition(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Add Step", "A stage must have one and only one of steps, stages, parallel, or matrix.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
	            IXtextDocument xtextDocument = context.getXtextDocument();
	            String documentContent = xtextDocument.get();
	            int offset = issue.getOffset();
	            
	            int lineStart = getLineStart(documentContent, offset);
	            int currentLineStart = lineStart;
	            int lineEnd;
	            boolean stop = false;

	            while (!stop) {
	                lineEnd = getLineEnd(documentContent, currentLineStart);
	                String line = documentContent.substring(currentLineStart, lineEnd).trim();
	                if (line.isEmpty() || lineEnd >= documentContent.length()) {
	                	stop = true;
	                    break;
	                }
	                currentLineStart = lineEnd;
	            }

	            String newStep = "\tStep\n\t\tCommand\n\t\t\tname echo\n";
	            xtextDocument.replace(currentLineStart, 0, newStep);
            }
        });
    }
	
	@Fix(JenkinsValidator.INVALID_STAGE_DEFINITION_ERRORCODE)
    public void fixInvalidStageDefinition2(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Add Matrix", "A stage must have one and only one of steps, stages, parallel, or matrix.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
	            IXtextDocument xtextDocument = context.getXtextDocument();
	            String documentContent = xtextDocument.get();
	            int offset = issue.getOffset();
	            
	            int lineStart = getLineStart(documentContent, offset);
	            int currentLineStart = lineStart;
	            int lineEnd;
	            boolean stop = false;

	            while (!stop) {
	                lineEnd = getLineEnd(documentContent, currentLineStart);
	                String line = documentContent.substring(currentLineStart, lineEnd).trim();
	                if (line.isEmpty() || lineEnd >= documentContent.length()) {
	                	stop = true;
	                    break;
	                }
	                currentLineStart = lineEnd;
	            }
	            int randomInt = (int) (Math.random() * 100);
	            String newMatrix = "\tMatrix\n\t\tAxis\n\t\t\tname AxisName\n\t\t\tvalues AxisVal\n\t\tStage\n\t\t\tname MatrixStage%s\n\t\t\tStep\n\t\t\t\tCommand\n\t\t\t\t\tname echo";
	            xtextDocument.replace(currentLineStart, 0, String.format(newMatrix, randomInt));
            }
        });
    }
	
	@Fix(JenkinsValidator.INVALID_STAGE_DEFINITION_ERRORCODE)
    public void fixInvalidStageDefinition3(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Add Substage", "A stage must have one and only one of steps, stages or matrix.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
	            IXtextDocument xtextDocument = context.getXtextDocument();
	            String documentContent = xtextDocument.get();
	            int offset = issue.getOffset();
	            
	            int lineStart = getLineStart(documentContent, offset);
	            int currentLineStart = lineStart;
	            int lineEnd;
	            boolean stop = false;

	            while (!stop) {
	                lineEnd = getLineEnd(documentContent, currentLineStart);
	                String line = documentContent.substring(currentLineStart, lineEnd).trim();
	                if (line.isEmpty() || lineEnd >= documentContent.length()) {
	                	stop = true;
	                    break;
	                }
	                currentLineStart = lineEnd;
	            }
	            int randomInt = (int) (Math.random() * 100);
	            String newSubstage = "\tStage\n\t\tname Substage%s\n\t\tparallel\n\t\tStep\n\t\t\tCommand\n\t\t\t\tname echo\n";
	            xtextDocument.replace(currentLineStart, 0, String.format(newSubstage, randomInt));
            }
        });
    }
	
	
	@Fix(JenkinsValidator.DUPLICATE_STAGE_NAME_ERRORCODE)
    public void fixDuplicateStageName(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Fix Duplicate Stage Name", "Rename the duplicate stage.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                Integer offset = issue.getOffset();
                Integer length = issue.getLength();
                String originalName = xtextDocument.get(offset, length);
                int randomInt = (int) (Math.random() * 100);
                String newName = originalName + randomInt;
                xtextDocument.replace(offset, length, newName);
            }
        });
    }

    @Fix(JenkinsValidator.INVALID_CRON_SYNTAX_ERRORCODE)
    public void fixInvalidCronSyntax(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Fix Invalid Cron Syntax", "Correct the cron syntax.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
                IXtextDocument xtextDocument = context.getXtextDocument();
                xtextDocument.replace(issue.getOffset(), issue.getLength(), "\"*/1 * * * *\"");
            }
        });
    }
    
    @Fix(JenkinsValidator.INVALID_POLL_CRON_SYNTAX_ERRORCODE)
    public void fixInvalidPollCronSyntax(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Fix Invalid Cron Syntax", "Correct the cron syntax.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
                IXtextDocument xtextDocument = context.getXtextDocument();
                xtextDocument.replace(issue.getOffset(), issue.getLength(), "\"*/1 * * * *\"");
            }
        });
    }

    @Fix(JenkinsValidator.AT_LEAST_ONE_INCLUDE_AXIS_ERRORCODE)
    public void fixNoAxisDefined(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Define one Axis with exclude set to false", "Add at least one axis with exclude set to false to the matrix.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
                IXtextDocument xtextDocument = context.getXtextDocument();
                String documentContent = xtextDocument.get();
	            int offset = issue.getOffset();
	            
	            int lineStart = getLineStart(documentContent, offset);
	            int currentLineStart = lineStart;
	            int lineEnd = 0;
	            boolean stop = false;
	            String newAxis = "PLATFORM\n\t\t\tvalues linux, mac, windows";
	            String nextLine = "";
	            
	            while (!stop) {
	                lineEnd = getLineEnd(documentContent, currentLineStart);
	                
	                if (lineEnd > documentContent.length()) {
	                    newAxis = "\n\t\t\tname " + newAxis + "\n";
	                    currentLineStart = documentContent.length();
	                    break;
	                }

	                String line = documentContent.substring(currentLineStart, lineEnd).trim();

	                if (line.isEmpty()) {
	                	stop = true;
	                	newAxis = "\t\tAxis\n\t\t\tname " + newAxis;
	                    break;
	                }
	                
	                if (line.startsWith("Axis") && lineEnd < documentContent.length()) {
	                    stop = true;
	                    int nextLineEnd = getLineEnd(documentContent, lineEnd);
	                    if (nextLineEnd < documentContent.length()) {
	                        nextLine = documentContent.substring(lineEnd, nextLineEnd).trim();
	                        if (nextLine.contains("name") || nextLine.contains("values")) {
	                        	newAxis = "\t\tAxis\n\t\t\tname " + newAxis + "\n";
	                        }
	                    }
	                    else if (nextLineEnd >= documentContent.length()) {
	                        newAxis = "\t\t\tname " + newAxis;
	                        currentLineStart = lineEnd;
	                    }
	                    break;
	                }
	                currentLineStart = lineEnd;
	            }
	            xtextDocument.replace(currentLineStart, 0, newAxis);
            }
        });
    }

    @Fix(JenkinsValidator.UPSTREAM_JOB_NOT_EXIST_ERRORCODE)
    public void fixUpstreamJobNotExist(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Fix Upstream Job Not found", "Correct the upstream job name.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                String documentContent = xtextDocument.get();
                List<String> stageNames = extractStageNames(documentContent);
                Integer offset = issue.getOffset();

                List<String> currentUpstreamJobsNames = extractCurrentUpstreamJobsName(documentContent, offset);
                Collections.shuffle(stageNames);
                String newJobName = stageNames.stream()
                                            .filter(name -> !currentUpstreamJobsNames.contains(name))
                                            .findFirst()
                                            .orElse(null);
                if (newJobName != null) {
                    xtextDocument.replace(offset, issue.getLength(), newJobName);
                } else {
                    int lineStart = getLineStart(documentContent, offset);
                    int lineEnd = getLineEnd(documentContent, offset);
                    xtextDocument.replace(lineStart, lineEnd - lineStart, "");
                }
            }
        });
    }

    @Fix(JenkinsValidator.PARALLEL_IN_SUBSTAGES_ERRORCODE)
    public void fixParallelInSubstages(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Fix Parallel in Substages", "Remove parallel execution in substages.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                int offset = issue.getOffset();
                String documentContent = xtextDocument.get();
                int lineStart = getLineStart(documentContent, offset);
                int lineEnd = getLineEnd(documentContent, offset);
                xtextDocument.replace(lineStart, lineEnd - lineStart, "");
            }
        });
    }

    @Fix(JenkinsValidator.NOT_PARALLEL_NO_SUBSTAGE_ERRORCODE)
    public void fixNotParallelNoSubstage(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Fix Not Parallel No Substage", "Remove parallel flag when no substage exists.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
            	IXtextDocument xtextDocument = context.getXtextDocument();
                int offset = issue.getOffset();
                String documentContent = xtextDocument.get();
                int lineStart = getLineStart(documentContent, offset);
                int lineEnd = getLineEnd(documentContent, offset);
                xtextDocument.replace(lineStart, lineEnd - lineStart, "");
            }
        });
    }

    @Fix(JenkinsValidator.NOT_ALL_SUBSTAGES_PARALLEL_ERRORCODE)
    public void fixAddParallel(Issue issue, IssueResolutionAcceptor acceptor) {
        acceptor.accept(issue, "Add 'parallel'", "Add 'parallel' after 'name' in the substage.", null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
                IXtextDocument xtextDocument = context.getXtextDocument();
                String documentContent = xtextDocument.get();
                int offset = issue.getOffset();

                int lineStart = getLineStart(documentContent, offset);
                int currentLineStart = lineStart;
                int lineEnd = 0;
                boolean stop = false;
                String newContent = "";

                while (!stop) {
                    lineEnd = getLineEnd(documentContent, currentLineStart);

                    if (lineEnd >= documentContent.length()) {
                        currentLineStart = documentContent.length();
                        break;
                    }

                    String line = documentContent.substring(currentLineStart, lineEnd).trim();

                    if (line.startsWith("name ")) {
                        stop = true;
                        newContent = "\t\tparallel\n";
                        currentLineStart = lineEnd;
                        break;
                    }

                    currentLineStart = lineEnd;
                }
                xtextDocument.replace(currentLineStart, 0, newContent);
            }
        });
    }
	
	
    @Fix(JenkinsValidator.MANDATORY_TOOL_NAME_EMPTY_ERRORCODE)
    public void fixEmptyToolName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Tool Name", acceptor, "\"New Tool Name\"");
    }

    @Fix(JenkinsValidator.MANDATORY_COMMAND_NAME_EMPTY_ERRORCODE)
    public void fixEmptyCommandName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty command name", acceptor, "\"New Command Name\"");
    }

    @Fix(JenkinsValidator.MANDATORY_NODE_LABEL_EMPTY_ERRORCODE)
    public void fixEmptyNodeLabel(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty node label", acceptor, "\"New Node Label\"");
    }

    @Fix(JenkinsValidator.MANDATORY_STAGE_NAME_EMPTY_ERRORCODE)
    public void fixEmptyStageName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty stage name", acceptor, "\"New Stage Name\"");
    }

    @Fix(JenkinsValidator.MANDATORY_ENVIRONMENT_KEY_EMPTY_ERRORCODE)
    public void fixEmptyEnvironmentKey(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty environment key", acceptor, "\"New Environment Key\"");
    }

    @Fix(JenkinsValidator.MANDATORY_ENVIRONMENT_VALUE_EMPTY_ERRORCODE)
    public void fixEmptyEnvironmentValue(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty environment value", acceptor, "\"New Environment Value\"");
    }

    @Fix(JenkinsValidator.MANDATORY_DOCKERFILE_FILENAME_EMPTY_ERRORCODE)
    public void fixEmptyDockerfileFilename(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Dockerfile filename", acceptor, "\"New Dockerfile Filename\"");
    }

    @Fix(JenkinsValidator.MANDATORY_LABEL_NAME_EMPTY_ERRORCODE)
    public void fixEmptyLabelName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty label name", acceptor, "\"New Label Name\"");
    }

    @Fix(JenkinsValidator.MANDATORY_INPUT_MESSAGE_EMPTY_ERRORCODE)
    public void fixEmptyInputMessage(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty input message", acceptor, "\"New Input Message\"");
    }

    @Fix(JenkinsValidator.MANDATORY_STEP_PARAMETER_EMPTY_ERRORCODE)
    public void fixEmptyStepParameter(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty step parameter", acceptor, "\"New StepParameter\"");
    }

    @Fix(JenkinsValidator.MANDATORY_AXIS_NAME_EMPTY_ERRORCODE)
    public void fixEmptyAxisName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty axis name", acceptor, "\"New Axis Name\"");
    }

    @Fix(JenkinsValidator.MANDATORY_AXIS_VALUES_EMPTY_ERRORCODE)
    public void fixEmptyAxisValues(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty axis values", acceptor, "\"New Axis Values\"");
    }

    @Fix(JenkinsValidator.MANDATORY_CRON_TIMER_EMPTY_ERRORCODE)
    public void fixEmptyCronTimer(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty cron timer", acceptor, "\"New Cron Timer\"");
    }

    @Fix(JenkinsValidator.MANDATORY_POLLSCM_TIMER_EMPTY_ERRORCODE)
    public void fixEmptyPollSCMTimer(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty PollSCM timer", acceptor, "\"New PollSCM Timer\"");
    }

    @Fix(JenkinsValidator.MANDATORY_UPSTREAM_JOBS_EMPTY_ERRORCODE)
    public void fixEmptyUpstreamJobs(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty upstream jobs", acceptor, "\"New Upstream Jobs\"");
    }

    @Fix(JenkinsValidator.MANDATORY_DOCKER_IMAGE_EMPTY_ERRORCODE)
    public void fixEmptyDockerImage(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Docker image", acceptor, "\"New Docker Image\"");
    }

    @Fix(JenkinsValidator.MANDATORY_TRIGGEREDBY_PARAMETER_EMPTY_ERRORCODE)
    public void fixEmptyTriggeredByParameter(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty TriggeredBy parameter", acceptor, "\"New TriggeredByParameter\"");
    }

    @Fix(JenkinsValidator.MANDATORY_CHANGELOG_EXPRESSION_EMPTY_ERRORCODE)
    public void fixEmptyChangelogExpression(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Changelog expression", acceptor, "\"New ChangelogExpression\"");
    }

    @Fix(JenkinsValidator.MANDATORY_EQUALS_EXPECTED_VAL_EMPTY_ERRORCODE)
    public void fixEmptyEqualsExpectedVal(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Equals expected_val", acceptor, "\"New ExpectedValue\"");
    }

    @Fix(JenkinsValidator.MANDATORY_EQUALS_ACTUAL_VAL_EMPTY_ERRORCODE)
    public void fixEmptyEqualsActualVal(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Equals actual_val", acceptor, "\"New ActualValue\"");
    }

    @Fix(JenkinsValidator.MANDATORY_WHEN_ENV_NAME_EMPTY_ERRORCODE)
    public void fixEmptyWhenEnvName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty When_Env name", acceptor, "\"New WhenEnv Name\"");
    }

    @Fix(JenkinsValidator.MANDATORY_WHEN_ENV_VALUE_EMPTY_ERRORCODE)
    public void fixEmptyWhenEnvValue(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty When_Env value", acceptor, "\"New WhenEnv Value\"");
    }

    @Fix(JenkinsValidator.MANDATORY_EXPRESSION_EXPRESSION_EMPTY_ERRORCODE)
    public void fixEmptyExpressionExpression(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Expression expression", acceptor, "\"New Expression Value\"");
    }

    @Fix(JenkinsValidator.MANDATORY_TAG_PATTERN_EMPTY_ERRORCODE)
    public void fixEmptyTagPattern(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Tag pattern", acceptor, "\"New Tag Pattern\"");
    }

    @Fix(JenkinsValidator.MANDATORY_CHANGESET_PATTERN_EMPTY_ERRORCODE)
    public void fixEmptyChangeSetPattern(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty ChangeSet pattern", acceptor, "\"New ChangeSet Pattern\"");
    }

    @Fix(JenkinsValidator.MANDATORY_BRANCH_PATTERN_EMPTY_ERRORCODE)
    public void fixEmptyBranchPattern(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Branch pattern", acceptor, "\"New Branch Pattern\"");
    }

    @Fix(JenkinsValidator.MANDATORY_CHANGEREQUEST_VALUE_EMPTY_ERRORCODE)
    public void fixEmptyChangeRequestValue(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty ChangeRequest value", acceptor, "\"New ChangeRequest Value\"");
    }

    @Fix(JenkinsValidator.MANDATORY_BOOLEANPARAM_NAME_EMPTY_ERRORCODE)
	public void fixEmptyBooleanParamName(Issue issue, IssueResolutionAcceptor acceptor) {
    	fixEmptyString(issue, "Fix empty BooleanParam name", acceptor, "\"New BooleanParam Name\"");
	}

    @Fix(JenkinsValidator.MANDATORY_CHOICEPARAM_NAME_EMPTY_ERRORCODE)
    public void fixEmptyChoiceParamName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty ChoiceParam name", acceptor, "\"New ChoiceParam Name\"");
    }

    @Fix(JenkinsValidator.MANDATORY_TEXTPARAM_NAME_EMPTY_ERRORCODE)
    public void fixEmptyTextParamName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty TextParam name", acceptor, "\"New TextParam Name\"");
    }

    @Fix(JenkinsValidator.MANDATORY_TEXTPARAM_DEFAULTVALUE_EMPTY_ERRORCODE)
    public void fixEmptyTextParamDefaultValue(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty TextParam defaultValue", acceptor, "\"New TextParam DefaultValue\"");
    }

    @Fix(JenkinsValidator.MANDATORY_PASSWORDPARAM_NAME_EMPTY_ERRORCODE)
    public void fixEmptyPasswordParamName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty PasswordParam name", acceptor, "\"New PasswordParam Name\"");
    }

    @Fix(JenkinsValidator.MANDATORY_PASSWORDPARAM_DEFAULTVALUE_EMPTY_ERRORCODE)
    public void fixEmptyPasswordParamDefaultValue(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty PasswordParam defaultValue", acceptor, "\"New PasswordParam DefaultValue\"");
    }

    @Fix(JenkinsValidator.MANDATORY_STRINGPARAM_NAME_EMPTY_ERRORCODE)
    public void fixEmptyStringParamName(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty StringParam name", acceptor, "\"New StringParam Name\"");
    }

    @Fix(JenkinsValidator.MANDATORY_STRINGPARAM_DEFAULTVALUE_EMPTY_ERRORCODE)
    public void fixEmptyStringParamDefaultValue(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty StringParam defaultValue", acceptor, "\"NewS tringParam DefaultValue\"");
    }

    @Fix(JenkinsValidator.MANDATORY_TIMEOUT_UNIT_EMPTY_ERRORCODE)
    public void fixEmptyTimeoutUnit(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty Timeout unit", acceptor, "\"New Timeout Unit\"");
    }

    @Fix(JenkinsValidator.MANDATORY_CHECKOUTTOSUBDIRECTORY_DIRECTORY_EMPTY_ERRORCODE)
    public void fixEmptyCheckoutToSubdirectoryDirectory(Issue issue, IssueResolutionAcceptor acceptor) {
        fixEmptyString(issue, "Fix empty CheckoutToSubdirectory directory", acceptor, "\"New CheckoutDirectory\"");
    }
    
    

    /*
     * Auxiliary Methods
     */
    
	private void fixEmptyString(Issue issue, String label, IssueResolutionAcceptor acceptor, String suggestion) {
        acceptor.accept(issue, label, suggestion, null, new IModification() {
            public void apply(IModificationContext context) throws BadLocationException {
                IXtextDocument xtextDocument = context.getXtextDocument();
                String newValue = suggestion; 
                xtextDocument.replace(issue.getOffset(), issue.getLength(), newValue);
            }
        });
    }
	
	private List<String> extractStageNames(String documentContent) {
        List<String> stageNames = new ArrayList<>();
        String stageKeyword = "Stage";
        String nameKeyword = "name ";
        String newline = "\n";
        boolean insideMatrix = false;
        int indentLevel = 0;
        
        String[] lines = documentContent.split(newline);
        for (int i = 0; i < lines.length; i++) {
        	String line = lines[i];
            String trimmedLine = line.trim();

            if (!trimmedLine.isEmpty()) {
            	indentLevel = line.indexOf(trimmedLine.charAt(0));
            }
            
            if (trimmedLine.startsWith("Matrix")) {
            	insideMatrix = true;
            } else if (trimmedLine.isEmpty()) {
            	insideMatrix = false;
            }

            if (!insideMatrix && indentLevel == 0) {
                if (trimmedLine.startsWith(stageKeyword)) {
                    while (++i < lines.length && !lines[i].trim().startsWith(nameKeyword)) {}
                    if (i < lines.length) {
                        String nameLine = lines[i].trim();
                        int nameIndex = nameLine.indexOf(nameKeyword);
                        String currentStageName = nameLine.substring(nameIndex + nameKeyword.length()).trim();
                        stageNames.add(currentStageName);
                    }
                }
            }
        }
        return stageNames;
    }
	
	private List<String> extractCurrentUpstreamJobsName(String documentContent, int offset) {
		String nameKeyword = "jobs ";
	    List<String> currentJobNames = new ArrayList<>();
	    
	    int nameIndex = documentContent.lastIndexOf(nameKeyword, offset);
	    while (nameIndex >= 0) {
	        int lineStart = documentContent.lastIndexOf("\n", nameIndex) + 1;
	        int lineEnd = documentContent.indexOf("\n", nameIndex);
	        String line = documentContent.substring(lineStart, lineEnd).trim();
	        if (line.startsWith(nameKeyword)) {
	            currentJobNames.add(line.substring(nameKeyword.length()).trim());
	        }
	        nameIndex = documentContent.lastIndexOf(nameKeyword, nameIndex - 1);
	    }
	    
	    return currentJobNames;
    }
	
	private int getLineStart(String documentContent, int offset) {
        int lineStart = offset;
        while (lineStart > 0 && documentContent.charAt(lineStart - 1) != '\n') {
            lineStart--;
        }
        return lineStart;
    }


    private int getLineEnd(String documentContent, int offset) {
        int lineEnd = offset;
        while (lineEnd < documentContent.length() && documentContent.charAt(lineEnd) != '\n') {
            lineEnd++;
        }
        return lineEnd + 1; // Include the newline character
    }
}

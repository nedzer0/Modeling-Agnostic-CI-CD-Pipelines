/*
 * generated by Xtext 2.34.0
 */
package org.xtext.example.circleci.validation;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;

import circleCI_metamodel.AttachWorkspace;
import circleCI_metamodel.Branch;
import circleCI_metamodel.Command;
import circleCI_metamodel.Docker;
import circleCI_metamodel.Docker_Auth;
import circleCI_metamodel.Docker_Aws_Auths;
import circleCI_metamodel.Environment;
import circleCI_metamodel.Executor;
import circleCI_metamodel.Job;
import circleCI_metamodel.JobWorkflow;
import circleCI_metamodel.MacOs;
import circleCI_metamodel.Machine;
import circleCI_metamodel.MatrixParams;
import circleCI_metamodel.Orb;
import circleCI_metamodel.PARAMETER_TYPES;
import circleCI_metamodel.Parameter;
import circleCI_metamodel.Parameters;
import circleCI_metamodel.PersistToWorkspace;
import circleCI_metamodel.Pipeline;
import circleCI_metamodel.RestoreCache;
import circleCI_metamodel.RunCommand;
import circleCI_metamodel.SaveCache;
import circleCI_metamodel.StoreArtifact;
import circleCI_metamodel.StoreTestResults;
import circleCI_metamodel.Trigger;
import circleCI_metamodel.When_Unless;
import circleCI_metamodel.Workflow;


/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class CircleciValidator extends AbstractCircleciValidator {
	
	public static final String JOB_NOT_FOUND = "Job referenced in the workflow with name '%s' does not exist in the Job's configuration";
	public static final String INVALID_PARAMETER_TYPE = "Invalid parameter type '%s'. Pipeline parameters can only have types: string, boolean, integer, or enum";
	public static final String INVALID_CRON_SYNTAX = "Not a valid Cron syntax for trigger '%s'. Ensure that the pattern follows the format: [minute] [hour] [day of month] [month] [day of week], where each field is separated by a space";
	public static final String DUPLICATE_JOB_NAME = "Duplicate job name found: %s. Choose a different job name to ensure uniqueness within the pipeline.";
	public static final String DUPLICATE_EXECUTOR_NAME = "Duplicate executor name found: %s. Choose a different executor name to ensure uniqueness within the pipeline.";
	public static final String DUPLICATE_COMMAND_NAME = "Duplicate command name found: %s. Choose a different command name to ensure uniqueness within the pipeline.";
	public static final String DUPLICATE_PARAMETER_NAME = "Duplicate parameter name found: %s. Choose a different parameter name to ensure uniqueness within the pipeline.";
	public static final String DUPLICATE_JOBWORKFLOW_NAME = "Duplicate jobWorkflow name found: %s. Choose a different jobWorkflow name to ensure uniqueness within the pipeline.";
	public static final String MULTIPLE_EXECUTOR_TYPES = "Each job should only specify one executor type. Please ensure that each job has a unique executor type assigned.";
	public static final String EXECUTOR_NOT_FOUND = "Executor '%s' does not exist in the pipeline configuration";
	public static final String REQUIRED_JOB_NOT_EXIST = "Required Job '%s' does not exist. Select an existing pipeline Job";
	public static final String NULL_ENUM_VALUES_ENTRY = "EnumValues entry must be defined if Parameter type ENUM";
	public static final String ENUM_VALUES_EMPTY = "Enum parameter must have non-empty enum values";
	public static final String ENUM_VALUES_NOT_EMPTY = "Non-enum parameter must not have enum values. Remove enumValues entry";
	public static final String INVALID_BOOLEAN_DEFAULT_VALUE = "Boolean parameter must have default value as 'true' or 'false'";
	public static final String MANDATORY_STRING_EMPTY = "%s cannot be empty";

	// Error codes
	public static final String JOB_NOT_FOUND_ERRORCODE = "JOB_NOT_FOUND";
	public static final String INVALID_PARAMETER_TYPE_ERRORCODE = "INVALID_PARAMETER_TYPE";
	public static final String INVALID_CRON_SYNTAX_ERRORCODE = "INVALID_CRON_SYNTAX";
	public static final String DUPLICATE_JOB_NAME_ERRORCODE = "DUPLICATE_JOB_NAME";
	public static final String DUPLICATE_EXECUTOR_NAME_ERRORCODE = "DUPLICATE_EXECUTOR_NAME";
	public static final String DUPLICATE_COMMAND_NAME_ERRORCODE = "DUPLICATE_COMMAND_NAME";
	public static final String DUPLICATE_PARAMETER_NAME_ERRORCODE = "DUPLICATE_PARAMETER_NAME";
	public static final String DUPLICATE_JOBWORKFLOW_NAME_ERRORCODE = "DUPLICATE_JOBWORKFLOW_NAME";
	public static final String MULTIPLE_EXECUTOR_TYPES_ERRORCODE = "MULTIPLE_EXECUTOR_TYPES";
	public static final String EXECUTOR_NOT_FOUND_ERRORCODE = "EXECUTOR_NOT_FOUND";
	public static final String REQUIRED_JOB_NOT_EXIST_ERRORCODE = "REQUIRED_JOB_NOT_EXIST";
	public static final String NULL_ENUM_VALUES_ENTRY_ERRORCODE = "NULL_ENUM_VALUES_ENTRY";
	public static final String ENUM_VALUES_EMPTY_ERRORCODE = "ENUM_VALUES_EMPTY";
	public static final String ENUM_VALUES_NOT_EMPTY_ERRORCODE = "ENUM_VALUES_NOT_EMPTY";
	public static final String INVALID_BOOLEAN_DEFAULT_VALUE_ERRORCODE = "INVALID_BOOLEAN_DEFAULT_VALUE";
	public static final String INVALID_DOCKER_RESOURCE_CLASS_ERRORCODE = "INVALID_DOCKER_RESOURCE_CLASS";
	public static final String INVALID_MACHINE_RESOURCE_CLASS_ERRORCODE = "INVALID_MACHINE_RESOURCE_CLASS";
	public static final String INVALID_MACOS_RESOURCE_CLASS_ERRORCODE = "INVALID_MACOS_RESOURCE_CLASS";
	
	public static final String MANDATORY_JOB_NAME_EMPTY_ERRORCODE = "MANDATORY_JOB_NAME_EMPTY";
	public static final String MANDATORY_COMMAND_NAME_EMPTY_ERRORCODE = "MANDATORY_COMMAND_NAME_EMPTY";
	public static final String MANDATORY_PARAMETER_NAME_EMPTY_ERRORCODE = "MANDATORY_PARAMETER_NAME_EMPTY";
	public static final String MANDATORY_PARAMETERS_PARAMETER_EMPTY_ERRORCODE = "MANDATORY_PARAMETERS_PARAMETER_EMPTY";
	public static final String MANDATORY_ENVIRONMENT_KEY_EMPTY_ERRORCODE = "MANDATORY_ENVIRONMENT_KEY_EMPTY";
	public static final String MANDATORY_ENVIRONMENT_VALUE_EMPTY_ERRORCODE = "MANDATORY_ENVIRONMENT_VALUE_EMPTY";
	public static final String MANDATORY_SAVE_CACHE_PATHS_EMPTY_ERRORCODE = "MANDATORY_SAVE_CACHE_PATHS_EMPTY";
	public static final String MANDATORY_SAVE_CACHE_KEY_EMPTY_ERRORCODE = "MANDATORY_SAVE_CACHE_KEY_EMPTY";
	public static final String MANDATORY_STORE_ARTIFACT_PATH_EMPTY_ERRORCODE = "MANDATORY_STORE_ARTIFACT_PATH_EMPTY";
	public static final String MANDATORY_ATTACH_WORKSPACE_AT_EMPTY_ERRORCODE = "MANDATORY_ATTACH_WORKSPACE_AT_EMPTY";
	public static final String MANDATORY_STORE_TEST_RESULTS_PATH_EMPTY_ERRORCODE = "MANDATORY_STORE_TEST_RESULTS_PATH_EMPTY";
	public static final String MANDATORY_PERSIST_TO_WORKSPACE_PATHS_EMPTY_ERRORCODE = "MANDATORY_PERSIST_TO_WORKSPACE_PATHS_EMPTY";
	public static final String MANDATORY_PERSIST_TO_WORKSPACE_ROOT_EMPTY_ERRORCODE = "MANDATORY_PERSIST_TO_WORKSPACE_ROOT_EMPTY";
	public static final String MANDATORY_RESTORE_CACHE_KEYS_EMPTY_ERRORCODE = "MANDATORY_RESTORE_CACHE_KEYS_EMPTY";
	public static final String MANDATORY_RESTORE_CACHE_KEY_EMPTY_ERRORCODE = "MANDATORY_RESTORE_CACHE_KEY_EMPTY";
	public static final String MANDATORY_BRANCH_NAME_EMPTY_ERRORCODE = "MANDATORY_BRANCH_NAME_EMPTY";
	public static final String MANDATORY_TRIGGER_CRON_EMPTY_ERRORCODE = "MANDATORY_TRIGGER_CRON_EMPTY";
	public static final String MANDATORY_JOB_WORKFLOW_NAME_EMPTY_ERRORCODE = "MANDATORY_JOB_WORKFLOW_NAME_EMPTY";
	public static final String MANDATORY_WORKFLOW_NAME_EMPTY_ERRORCODE = "MANDATORY_WORKFLOW_NAME_EMPTY";
	public static final String MANDATORY_WORKFLOW_VERSION_EMPTY_ERRORCODE = "MANDATORY_WORKFLOW_VERSION_EMPTY";
	public static final String MANDATORY_MACOS_XCODE_EMPTY_ERRORCODE = "MANDATORY_MACOS_XCODE_EMPTY";
	public static final String MANDATORY_MACOS_NAME_EMPTY_ERRORCODE = "MANDATORY_MACOS_NAME_EMPTY";
	public static final String MANDATORY_MACHINE_IMAGE_EMPTY_ERRORCODE = "MANDATORY_MACHINE_IMAGE_EMPTY";
	public static final String MANDATORY_MACHINE_NAME_EMPTY_ERRORCODE = "MANDATORY_MACHINE_NAME_EMPTY";
	public static final String MANDATORY_DOCKER_IMAGE_EMPTY_ERRORCODE = "MANDATORY_DOCKER_IMAGE_EMPTY";
	public static final String MANDATORY_DOCKER_NAME_EMPTY_ERRORCODE = "MANDATORY_DOCKER_NAME_EMPTY";
	public static final String MANDATORY_DOCKER_AUTH_USERNAME_EMPTY_ERRORCODE = "MANDATORY_DOCKER_AUTH_USERNAME_EMPTY";
	public static final String MANDATORY_DOCKER_AUTH_PASSWORD_EMPTY_ERRORCODE = "MANDATORY_DOCKER_AUTH_PASSWORD_EMPTY";
	public static final String MANDATORY_DOCKER_AWS_AUTHS_ACCESS_KEY_ID_EMPTY_ERRORCODE = "MANDATORY_DOCKER_AWS_AUTHS_ACCESS_KEY_ID_EMPTY";
	public static final String MANDATORY_DOCKER_AWS_AUTHS_SECRET_ACCESS_KEY_EMPTY_ERRORCODE = "MANDATORY_DOCKER_AWS_AUTHS_SECRET_ACCESS_KEY_EMPTY";
	public static final String MANDATORY_MATRIX_PARAMS_KEY_EMPTY_ERRORCODE = "MANDATORY_MATRIX_PARAMS_KEY_EMPTY";
	public static final String MANDATORY_MATRIX_PARAMS_VALUES_EMPTY_ERRORCODE = "MANDATORY_MATRIX_PARAMS_VALUES_EMPTY";
	public static final String MANDATORY_PIPELINE_VERSION_EMPTY_ERRORCODE = "MANDATORY_PIPELINE_VERSION_EMPTY";
	public static final String MANDATORY_RUN_COMMAND_NAME_EMPTY_ERRORCODE = "MANDATORY_RUN_COMMAND_NAME_NAME_EMPTY";
	public static final String MANDATORY_WHEN_UNLESS_CONDITION_EMPTY_ERRORCODE = "MANDATORY_WHEN_UNLESS_CONDITION_EMPTY";
	public static final String MANDATORY_ORB_KEY_EMPTY_ERRORCODE = "MANDATORY_ORB_KEY_EMPTY";
	public static final String MANDATORY_ORB_VALUE_EMPTY_ERRORCODE = "MANDATORY_ORB_VALUE_EMPTY";

	@Check
	public void checkWorkflowJobExists(JobWorkflow jobWorkflow) {
	    Workflow workflow = (Workflow) jobWorkflow.eContainer();
	    Pipeline pipeline = (Pipeline) workflow.eContainer();
	    if (!pipeline.getJobs().stream().anyMatch(job -> job.getName().equals(jobWorkflow.getName()))) {
	        EStructuralFeature nameFeature = jobWorkflow.eClass().getEStructuralFeature("name");
	        error(String.format(JOB_NOT_FOUND, jobWorkflow.getName()), jobWorkflow, nameFeature, JOB_NOT_FOUND_ERRORCODE);
	    }
	}

	@Check
	public void checkValidParameterTypes(Parameter param) {
	    if (!(param.getType().equals(PARAMETER_TYPES.STRING) ||
	          param.getType().equals(PARAMETER_TYPES.BOOLEAN) ||
	          param.getType().equals(PARAMETER_TYPES.INTEGER) ||
	          param.getType().equals(PARAMETER_TYPES.ENUM))) {
	        EStructuralFeature typeFeature = param.eClass().getEStructuralFeature("type");
	        error(String.format(INVALID_PARAMETER_TYPE, param.getType()), param, typeFeature, INVALID_PARAMETER_TYPE_ERRORCODE);
	    }
	}

	@Check
	public void checkValidCronSyntax(Trigger trigger) {
	    Workflow workflow = (Workflow) trigger.eContainer();
	    if (!trigger.getCron().matches("(?:[0-9]|1[0-9]|2[0-3]|H|L|\\*|\\?|[0-5]?[0-9]|\\*/[0-9]+) (?:[0-9]|1[0-9]|2[0-3]|\\*|L|\\?|[01]?[0-9]|2[0-9]|3[01]|W|L\\-?[0-6]|#[1-5]|\\*/[0-9]+) (?:[0-9]|1[0-9]|2[0-3]|\\*|L|\\?|[01]?[0-9]|2[0-9]|3[01]|W|L\\-?[0-6]|#[1-5]) (?:[0-9]|1[0-2]|\\*|L|\\?|\\*/[0-9]+) (?:[0-7]|\\*|L|\\?|#[1-5])")) {
	        EStructuralFeature cronFeature = workflow.eClass().getEStructuralFeature("cron");
	        error(String.format(INVALID_CRON_SYNTAX, trigger.getCron()), trigger, cronFeature, INVALID_CRON_SYNTAX_ERRORCODE);
	    }
	}

	
	@Check
	public void checkNonDuplicateJobName(Job job) {
	    Pipeline pipeline = (Pipeline) job.eContainer();
	    for (Job otherJob : pipeline.getJobs()) {
	        if (otherJob != job && otherJob.getName().equals(job.getName())) {
	            EStructuralFeature nameFeature = job.eClass().getEStructuralFeature("name");
	            error(String.format(DUPLICATE_JOB_NAME, job.getName()), job, nameFeature, DUPLICATE_JOB_NAME_ERRORCODE);
	        }
	    }
	}
	
	@Check
	public void checkNonDuplicateExecutorName(Executor exec) {
		Pipeline pipeline = null;

	    EObject container = exec.eContainer();
	    if (container instanceof Job) {
	        pipeline = (Pipeline) container.eContainer();
	    } else if (container instanceof Pipeline) {
	        pipeline = (Pipeline) exec.eContainer();
	    }
        
        List<Executor> execs = new ArrayList<>();
        for (Executor c : pipeline.getExecutors()) {
        	execs.add(c);
        }
        for (Job j : pipeline.getJobs()) {
        	execs.addAll(j.getExecutors());
        }
        
        Set<String> uniqueNames = new HashSet<>();
        Set<String> duplicateNames = new HashSet<>();
        for (Executor e : execs) {
            if (!uniqueNames.add(e.getName())) {
                duplicateNames.add(e.getName());
            }
        }

        if (duplicateNames.contains(exec.getName())) {
            EStructuralFeature nameFeature = exec.eClass().getEStructuralFeature("name");
            error(String.format(DUPLICATE_EXECUTOR_NAME, exec.getName()), exec, nameFeature, DUPLICATE_EXECUTOR_NAME_ERRORCODE);
        }
	}
	
	@Check
	public void checkNonDuplicateCommandName(Command c) {
	    Pipeline pipeline = (Pipeline) c.eContainer();
	    for (Command otherCommand : pipeline.getCommands()) {
	        if (otherCommand != c && otherCommand.getName().equals(c.getName())) {
	            EStructuralFeature nameFeature = c.eClass().getEStructuralFeature("name");
	            error(String.format(DUPLICATE_COMMAND_NAME, c.getName()), c, nameFeature, DUPLICATE_COMMAND_NAME_ERRORCODE);
	        }
	    }
	}
	
	@Check
    public void checkNonDuplicateParameterName(Parameter param) {
		Pipeline pipeline = null;

	    EObject container = param.eContainer();
	    if (container instanceof Command) {
	        pipeline = (Pipeline) container.eContainer();
	    } else if (container instanceof Job) {
	        pipeline = (Pipeline) container.eContainer();
	    }
        
        List<Parameter> params = new ArrayList<>();
        for (Command c : pipeline.getCommands()) {
            params.addAll(c.getParameters());
        }
        for (Job j : pipeline.getJobs()) {
            params.addAll(j.getParameters());
        }
        
        Set<String> uniqueNames = new HashSet<>();
        Set<String> duplicateNames = new HashSet<>();
        for (Parameter p : params) {
            if (!uniqueNames.add(p.getName())) {
                duplicateNames.add(p.getName());
            }
        }

        if (duplicateNames.contains(param.getName())) {
            EStructuralFeature nameFeature = param.eClass().getEStructuralFeature("name");
            error(String.format(DUPLICATE_PARAMETER_NAME, param.getName()), param, nameFeature, DUPLICATE_PARAMETER_NAME_ERRORCODE);
        }
    }
	
	@Check
	public void checkNonDuplicateJobWorkflowName(JobWorkflow jobWorkflow) {
		Workflow workflow = (Workflow) jobWorkflow.eContainer();
	    for (JobWorkflow otherJobWorkflow : workflow.getJobworkflow()) {
	        if (otherJobWorkflow != jobWorkflow && otherJobWorkflow.getName().equals(jobWorkflow.getName())) {
	            EStructuralFeature nameFeature = jobWorkflow.eClass().getEStructuralFeature("name");
	            error(String.format(DUPLICATE_JOBWORKFLOW_NAME, jobWorkflow.getName()), jobWorkflow, nameFeature, DUPLICATE_JOBWORKFLOW_NAME_ERRORCODE);
	        }
	    }
	}

	@Check
	public void checkExecutorType(Job job) {
	    long uniqueExecutorTypes = job.getExecutors().stream()
	            .map(executor -> executor.eClass())
	            .distinct()
	            .count();

	    if (uniqueExecutorTypes > 1) {
	        error(MULTIPLE_EXECUTOR_TYPES, job, null, MULTIPLE_EXECUTOR_TYPES_ERRORCODE);
	    }
	}

	@Check
	public void checkExecutorExistsInJobs(Job job) {
	    if (job.getReuseExecutor() != null && !job.getReuseExecutor().isEmpty()) {
	        Pipeline pipeline = (Pipeline) job.eContainer();
	        for (Executor ex : pipeline.getExecutors()) {
	            if (ex.getName().equals(job.getReuseExecutor())) {
	                return;
	            }
	        }
	        EStructuralFeature reuseExecutorFeature = job.eClass().getEStructuralFeature("reuseExecutor");
	        error(String.format(EXECUTOR_NOT_FOUND, job.getReuseExecutor()), job, reuseExecutorFeature, EXECUTOR_NOT_FOUND_ERRORCODE);
	    }
	}

	@Check
	public void checkRequiredJobExists(JobWorkflow jobWorkflow) {
	    if (!jobWorkflow.getRequires().isEmpty()) {
	        Workflow workflow = (Workflow) jobWorkflow.eContainer();
	        Pipeline pipeline = (Pipeline) workflow.eContainer();
	        Set<String> existingJobNames = new HashSet<>();
	        for (Job job : pipeline.getJobs()) {
	            existingJobNames.add(job.getName());
	        }

	        for (String requiredJob : jobWorkflow.getRequires()) {
	            if (!existingJobNames.contains(requiredJob)) {
	            	int index = jobWorkflow.getRequires().indexOf(requiredJob);
	                EStructuralFeature requiresFeature = jobWorkflow.eClass().getEStructuralFeature("requires");
	                error(String.format(REQUIRED_JOB_NOT_EXIST, requiredJob), jobWorkflow, requiresFeature, index, REQUIRED_JOB_NOT_EXIST_ERRORCODE);
	            }
	        }
	    }
	}

	@Check
	public void checkEnumValues(Parameter param) {
		EStructuralFeature enumValuesFeature = param.eClass().getEStructuralFeature("enumValues");
	    if (param.getType().equals(PARAMETER_TYPES.ENUM)) {
	    	List<String> enumValues = param.getEnumValues();
	    	
	    	if (enumValues.isEmpty()) {
	    		error(NULL_ENUM_VALUES_ENTRY, param, null, NULL_ENUM_VALUES_ENTRY_ERRORCODE);
	        }
	    	else if (enumValues.stream().anyMatch(String::isEmpty)) {
	            for (int i = 0; i < enumValues.size(); i++) {
	                String value = enumValues.get(i);
	                if (value.isEmpty()) {
	                    error(ENUM_VALUES_EMPTY, param, enumValuesFeature, i, ENUM_VALUES_EMPTY_ERRORCODE);
	                }
	            }
	        }
	    } else {
	        if (param.getEnumValues() != null && !param.getEnumValues().isEmpty()) {
	            error(ENUM_VALUES_NOT_EMPTY, param, enumValuesFeature, ENUM_VALUES_NOT_EMPTY_ERRORCODE);
	        }
	    }
	}

	@Check
	public void checkBooleanDefaultValue(Parameter param) {
	    if (param.getType().equals(PARAMETER_TYPES.BOOLEAN)) {
	        String defaultValue = param.getDefault();
	        if (!defaultValue.equalsIgnoreCase("true") && !defaultValue.equalsIgnoreCase("false")) {
	            EStructuralFeature defaultValueFeature = param.eClass().getEStructuralFeature("default");
	            error(INVALID_BOOLEAN_DEFAULT_VALUE, param, defaultValueFeature, INVALID_BOOLEAN_DEFAULT_VALUE_ERRORCODE);
	        }
	    }
	}
	
	/*
	 * Validators to check mandatory attributes
	 */		
	
	
	@Check
	public void checkNameNotEmpty(Job job) {
	    checkMandatoryStringNotEmpty(job.getName(), String.format(MANDATORY_STRING_EMPTY, "Job name"), job, "name", MANDATORY_JOB_NAME_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(Command command) {
	    checkMandatoryStringNotEmpty(command.getName(), String.format(MANDATORY_STRING_EMPTY, "Command name"), command, "name", MANDATORY_COMMAND_NAME_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(Parameter parameter) {
	    checkMandatoryStringNotEmpty(parameter.getName(), String.format(MANDATORY_STRING_EMPTY, "Parameter name"), parameter, "name", MANDATORY_PARAMETER_NAME_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(Parameters parameters) {
	    checkMandatoryStringNotEmpty(parameters.getParameter(), String.format(MANDATORY_STRING_EMPTY, "Parameters parameter"), parameters, "parameter", MANDATORY_PARAMETERS_PARAMETER_EMPTY_ERRORCODE);
	}

	@Check
	public void checkKeyAndValueNotEmpty(Environment environment) {
	    checkMandatoryStringNotEmpty(environment.getKey(), String.format(MANDATORY_STRING_EMPTY, "Environment key"), environment, "key", MANDATORY_ENVIRONMENT_KEY_EMPTY_ERRORCODE);
	    checkMandatoryStringNotEmpty(environment.getValue(), String.format(MANDATORY_STRING_EMPTY, "Environment value"), environment, "value", MANDATORY_ENVIRONMENT_VALUE_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(SaveCache cache) {
	    checkMandatoryListNotEmpty(cache.getPaths(), String.format(MANDATORY_STRING_EMPTY, "SaveCache paths"), cache, "paths", MANDATORY_SAVE_CACHE_PATHS_EMPTY_ERRORCODE);
	    checkMandatoryStringNotEmpty(cache.getKey(), String.format(MANDATORY_STRING_EMPTY, "SaveCache key"), cache, "key", MANDATORY_SAVE_CACHE_KEY_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(StoreArtifact artifact) {
	    checkMandatoryStringNotEmpty(artifact.getPath(), String.format(MANDATORY_STRING_EMPTY, "StoreArtifact path"), artifact, "path", MANDATORY_STORE_ARTIFACT_PATH_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(AttachWorkspace work) {
	    checkMandatoryStringNotEmpty(work.getAt(), String.format(MANDATORY_STRING_EMPTY, "AttachWorkspace at"), work, "at", MANDATORY_ATTACH_WORKSPACE_AT_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(StoreTestResults results) {
	    checkMandatoryStringNotEmpty(results.getPath(), String.format(MANDATORY_STRING_EMPTY, "StoreTestResults path"), results, "path", MANDATORY_STORE_TEST_RESULTS_PATH_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(PersistToWorkspace workspace) {
	    checkMandatoryListNotEmpty(workspace.getPaths(), String.format(MANDATORY_STRING_EMPTY, "PersistToWorkspace paths"), workspace, "paths", MANDATORY_PERSIST_TO_WORKSPACE_PATHS_EMPTY_ERRORCODE);
	    checkMandatoryStringNotEmpty(workspace.getRoot(), String.format(MANDATORY_STRING_EMPTY, "PersistToWorkspace root"), workspace, "root", MANDATORY_PERSIST_TO_WORKSPACE_ROOT_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(RestoreCache cache) {
	    checkMandatoryListNotEmpty(cache.getKeys(), String.format(MANDATORY_STRING_EMPTY, "RestoreCache keys"), cache, "keys", MANDATORY_RESTORE_CACHE_KEYS_EMPTY_ERRORCODE);
	    checkMandatoryStringNotEmpty(cache.getKey(), String.format(MANDATORY_STRING_EMPTY, "RestoreCache key"), cache, "key", MANDATORY_RESTORE_CACHE_KEY_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(Branch branch) {
	    checkMandatoryStringNotEmpty(branch.getName(), String.format(MANDATORY_STRING_EMPTY, "Branch name"), branch, "name", MANDATORY_BRANCH_NAME_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(Trigger trigger) {
	    checkMandatoryStringNotEmpty(trigger.getCron(), String.format(MANDATORY_STRING_EMPTY, "Trigger cron"), trigger, "cron", MANDATORY_TRIGGER_CRON_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(JobWorkflow jobWorkflow) {
	    checkMandatoryStringNotEmpty(jobWorkflow.getName(), String.format(MANDATORY_STRING_EMPTY, "JobWorkflow name"), jobWorkflow, "name", MANDATORY_JOB_WORKFLOW_NAME_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(Workflow workflow) {
	    checkMandatoryStringNotEmpty(workflow.getName(), String.format(MANDATORY_STRING_EMPTY, "Workflow name"), workflow, "name", MANDATORY_WORKFLOW_NAME_EMPTY_ERRORCODE);
	    checkMandatoryStringNotEmpty(workflow.getVersion(), String.format(MANDATORY_STRING_EMPTY, "Workflow version"), workflow, "version", MANDATORY_WORKFLOW_VERSION_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(MacOs macOs) {
	    checkMandatoryStringNotEmpty(macOs.getXcode(), String.format(MANDATORY_STRING_EMPTY, "MacOs xcode"), macOs, "xcode", MANDATORY_MACOS_XCODE_EMPTY_ERRORCODE);
	    checkMandatoryStringNotEmpty(macOs.getName(), String.format(MANDATORY_STRING_EMPTY, "MacOs name"), macOs, "name", MANDATORY_MACOS_NAME_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(Machine machine) {
	    checkMandatoryStringNotEmpty(machine.getImage(), String.format(MANDATORY_STRING_EMPTY, "Machine image"), machine, "image", MANDATORY_MACHINE_IMAGE_EMPTY_ERRORCODE);
	    checkMandatoryStringNotEmpty(machine.getName(), String.format(MANDATORY_STRING_EMPTY, "Machine name"), machine, "name", MANDATORY_MACHINE_NAME_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(Docker docker) {
	    checkMandatoryStringNotEmpty(docker.getImage(), String.format(MANDATORY_STRING_EMPTY, "Docker image"), docker, "image", MANDATORY_DOCKER_IMAGE_EMPTY_ERRORCODE);
	    checkMandatoryStringNotEmpty(docker.getName(), String.format(MANDATORY_STRING_EMPTY, "Docker name"), docker, "name", MANDATORY_DOCKER_NAME_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(Docker_Auth dockerAuth) {
	    checkMandatoryStringNotEmpty(dockerAuth.getUsername(), String.format(MANDATORY_STRING_EMPTY, "Docker_Auth username"), dockerAuth, "username", MANDATORY_DOCKER_AUTH_USERNAME_EMPTY_ERRORCODE);
	    checkMandatoryStringNotEmpty(dockerAuth.getPassword(), String.format(MANDATORY_STRING_EMPTY, "Docker_Auth password"), dockerAuth, "password", MANDATORY_DOCKER_AUTH_PASSWORD_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(Docker_Aws_Auths dockerAwsAuths) {
	    checkMandatoryStringNotEmpty(dockerAwsAuths.getAws_access_key_id(), String.format(MANDATORY_STRING_EMPTY, "Docker_Aws_Auths aws_access_key_id"), dockerAwsAuths, "awsAccessKeyId", MANDATORY_DOCKER_AWS_AUTHS_ACCESS_KEY_ID_EMPTY_ERRORCODE);
	    checkMandatoryStringNotEmpty(dockerAwsAuths.getAws_secret_access_key(), String.format(MANDATORY_STRING_EMPTY, "Docker_Aws_Auths aws_secret_access_key"), dockerAwsAuths, "awsSecretAccessKey", MANDATORY_DOCKER_AWS_AUTHS_SECRET_ACCESS_KEY_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(MatrixParams matrixParams) {
	    checkMandatoryStringNotEmpty(matrixParams.getKey(), String.format(MANDATORY_STRING_EMPTY, "MatrixParams key"), matrixParams, "key", MANDATORY_MATRIX_PARAMS_KEY_EMPTY_ERRORCODE);
	    checkMandatoryListNotEmpty(matrixParams.getValues(), String.format(MANDATORY_STRING_EMPTY, "MatrixParams values"), matrixParams, "values", MANDATORY_MATRIX_PARAMS_VALUES_EMPTY_ERRORCODE);
	}

	@Check
	public void checkVersionNotEmpty(Pipeline pipeline) {
	    checkMandatoryStringNotEmpty(pipeline.getVersion(), String.format(MANDATORY_STRING_EMPTY, "Pipeline version"), pipeline, "version", MANDATORY_PIPELINE_VERSION_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(RunCommand runCommand) {
	    checkMandatoryStringNotEmpty(runCommand.getName(), String.format(MANDATORY_STRING_EMPTY, "RunCommand name"), runCommand, "name", MANDATORY_RUN_COMMAND_NAME_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(When_Unless when_Unless) {
	    checkMandatoryStringNotEmpty(when_Unless.getCondition(), String.format(MANDATORY_STRING_EMPTY, "When_Unless condition"), when_Unless, "condition", MANDATORY_WHEN_UNLESS_CONDITION_EMPTY_ERRORCODE);
	}

	@Check
	public void checkNameNotEmpty(Orb orb) {
	    checkMandatoryStringNotEmpty(orb.getKey(), String.format(MANDATORY_STRING_EMPTY, "Orb key"), orb, "key", MANDATORY_ORB_KEY_EMPTY_ERRORCODE);
	    checkMandatoryStringNotEmpty(orb.getValue(), String.format(MANDATORY_STRING_EMPTY, "Orb value"), orb, "value", MANDATORY_ORB_VALUE_EMPTY_ERRORCODE);
	}
	
    
    /*
     * Auxiliary methods
     */
    
	private void checkMandatoryStringNotEmpty(String value, String errorMessage, Object object, String featureName, String errorCode) {
        if (value == null || value.trim().isEmpty()) {
            EStructuralFeature feature = ((EObject) object).eClass().getEStructuralFeature(featureName);
            error(errorMessage, (EObject) object, feature, errorCode);
        }
    }
    
    private void checkMandatoryListNotEmpty(List<String> values, String errorMessage, Object object, String featureName, String errorCode) {
        if (values.isEmpty() || values.stream().anyMatch(value -> value.equals(""))) {
            EStructuralFeature feature = ((EObject) object).eClass().getEStructuralFeature(featureName);
            error(errorMessage, (EObject) object, feature, errorCode);
        }
    }
}

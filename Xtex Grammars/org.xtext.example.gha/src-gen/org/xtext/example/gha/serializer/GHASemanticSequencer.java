/*
 * generated by Xtext 2.34.0
 */
package org.xtext.example.gha.serializer;

import com.google.inject.Inject;
import gHA_metamodel.Artifact;
import gHA_metamodel.Branch;
import gHA_metamodel.Command;
import gHA_metamodel.Concurrency;
import gHA_metamodel.Container;
import gHA_metamodel.Credentials;
import gHA_metamodel.DefaultSetting;
import gHA_metamodel.Docker;
import gHA_metamodel.Env;
import gHA_metamodel.Environment;
import gHA_metamodel.GHA_metamodelPackage;
import gHA_metamodel.If;
import gHA_metamodel.Input;
import gHA_metamodel.InputPair;
import gHA_metamodel.InputParams;
import gHA_metamodel.Job;
import gHA_metamodel.MatrixConfig;
import gHA_metamodel.Need;
import gHA_metamodel.Output;
import gHA_metamodel.Path;
import gHA_metamodel.Permission;
import gHA_metamodel.Pipeline;
import gHA_metamodel.PullTargetTrigger;
import gHA_metamodel.PullTrigger;
import gHA_metamodel.PushTrigger;
import gHA_metamodel.RestoreCache;
import gHA_metamodel.Runs_On;
import gHA_metamodel.SaveCache;
import gHA_metamodel.ScheduleTrigger;
import gHA_metamodel.Secret;
import gHA_metamodel.Service;
import gHA_metamodel.StandardEventTrigger;
import gHA_metamodel.Step;
import gHA_metamodel.Strategy;
import gHA_metamodel.Tag;
import gHA_metamodel.WorkflowCallTrigger;
import gHA_metamodel.WorkflowDispatchTrigger;
import gHA_metamodel.WorkflowRunTrigger;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.gha.services.GHAGrammarAccess;

@SuppressWarnings("all")
public class GHASemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GHAGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GHA_metamodelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GHA_metamodelPackage.ACTION:
				sequence_Action_Impl(context, (gHA_metamodel.Action) semanticObject); 
				return; 
			case GHA_metamodelPackage.ARTIFACT:
				sequence_Artifact(context, (Artifact) semanticObject); 
				return; 
			case GHA_metamodelPackage.BRANCH:
				sequence_Branch(context, (Branch) semanticObject); 
				return; 
			case GHA_metamodelPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case GHA_metamodelPackage.CONCURRENCY:
				sequence_Concurrency(context, (Concurrency) semanticObject); 
				return; 
			case GHA_metamodelPackage.CONTAINER:
				sequence_Container(context, (Container) semanticObject); 
				return; 
			case GHA_metamodelPackage.CREDENTIALS:
				sequence_Credentials(context, (Credentials) semanticObject); 
				return; 
			case GHA_metamodelPackage.DEFAULT_SETTING:
				sequence_DefaultSetting(context, (DefaultSetting) semanticObject); 
				return; 
			case GHA_metamodelPackage.DOCKER:
				sequence_Docker(context, (Docker) semanticObject); 
				return; 
			case GHA_metamodelPackage.ENV:
				sequence_Env(context, (Env) semanticObject); 
				return; 
			case GHA_metamodelPackage.ENVIRONMENT:
				sequence_Environment(context, (Environment) semanticObject); 
				return; 
			case GHA_metamodelPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case GHA_metamodelPackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case GHA_metamodelPackage.INPUT_PAIR:
				sequence_InputPair(context, (InputPair) semanticObject); 
				return; 
			case GHA_metamodelPackage.INPUT_PARAMS:
				sequence_InputParams(context, (InputParams) semanticObject); 
				return; 
			case GHA_metamodelPackage.JOB:
				sequence_Job(context, (Job) semanticObject); 
				return; 
			case GHA_metamodelPackage.MATRIX_CONFIG:
				sequence_MatrixConfig(context, (MatrixConfig) semanticObject); 
				return; 
			case GHA_metamodelPackage.NEED:
				sequence_Need(context, (Need) semanticObject); 
				return; 
			case GHA_metamodelPackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case GHA_metamodelPackage.PARAMETER:
				sequence_Parameter(context, (gHA_metamodel.Parameter) semanticObject); 
				return; 
			case GHA_metamodelPackage.PATH:
				sequence_Path(context, (Path) semanticObject); 
				return; 
			case GHA_metamodelPackage.PERMISSION:
				sequence_Permission(context, (Permission) semanticObject); 
				return; 
			case GHA_metamodelPackage.PIPELINE:
				sequence_Pipeline(context, (Pipeline) semanticObject); 
				return; 
			case GHA_metamodelPackage.PULL_TARGET_TRIGGER:
				sequence_PullTargetTrigger(context, (PullTargetTrigger) semanticObject); 
				return; 
			case GHA_metamodelPackage.PULL_TRIGGER:
				sequence_PullTrigger(context, (PullTrigger) semanticObject); 
				return; 
			case GHA_metamodelPackage.PUSH_TRIGGER:
				sequence_PushTrigger(context, (PushTrigger) semanticObject); 
				return; 
			case GHA_metamodelPackage.RESTORE_CACHE:
				sequence_RestoreCache(context, (RestoreCache) semanticObject); 
				return; 
			case GHA_metamodelPackage.RUNS_ON:
				sequence_Runs_On(context, (Runs_On) semanticObject); 
				return; 
			case GHA_metamodelPackage.SAVE_CACHE:
				sequence_SaveCache(context, (SaveCache) semanticObject); 
				return; 
			case GHA_metamodelPackage.SCHEDULE_TRIGGER:
				sequence_ScheduleTrigger(context, (ScheduleTrigger) semanticObject); 
				return; 
			case GHA_metamodelPackage.SECRET:
				sequence_Secret(context, (Secret) semanticObject); 
				return; 
			case GHA_metamodelPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case GHA_metamodelPackage.STANDARD_EVENT_TRIGGER:
				sequence_StandardEventTrigger(context, (StandardEventTrigger) semanticObject); 
				return; 
			case GHA_metamodelPackage.STEP:
				sequence_Step(context, (Step) semanticObject); 
				return; 
			case GHA_metamodelPackage.STRATEGY:
				sequence_Strategy(context, (Strategy) semanticObject); 
				return; 
			case GHA_metamodelPackage.TAG:
				sequence_Tag(context, (Tag) semanticObject); 
				return; 
			case GHA_metamodelPackage.WORKFLOW_CALL_TRIGGER:
				sequence_WorkflowCallTrigger(context, (WorkflowCallTrigger) semanticObject); 
				return; 
			case GHA_metamodelPackage.WORKFLOW_DISPATCH_TRIGGER:
				sequence_WorkflowDispatchTrigger(context, (WorkflowDispatchTrigger) semanticObject); 
				return; 
			case GHA_metamodelPackage.WORKFLOW_RUN_TRIGGER:
				sequence_WorkflowRunTrigger(context, (WorkflowRunTrigger) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Action
	 *     Action_Impl returns Action
	 *
	 * Constraint:
	 *     (uses=EString with+=InputParams* composite_action+=Step* with_inputPair=InputPair?)
	 * </pre>
	 */
	protected void sequence_Action_Impl(ISerializationContext context, gHA_metamodel.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Artifact
	 *     Artifact returns Artifact
	 *
	 * Constraint:
	 *     (
	 *         uses=EString 
	 *         name=EString 
	 *         paths+=EString 
	 *         paths+=EString* 
	 *         retention_days=EString? 
	 *         type=ARTIFACT_TYPE? 
	 *         composite_action+=Step* 
	 *         with+=InputParams* 
	 *         with_inputPair=InputPair?
	 *     )
	 * </pre>
	 */
	protected void sequence_Artifact(ISerializationContext context, Artifact semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Branch returns Branch
	 *
	 * Constraint:
	 *     (name=EString ignore?='ignore'?)
	 * </pre>
	 */
	protected void sequence_Branch(ISerializationContext context, Branch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Command
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.COMMAND__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.COMMAND__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommandAccess().getNameEStringParserRuleCall_2_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concurrency returns Concurrency
	 *
	 * Constraint:
	 *     (cancel_in_progress?='cancel_in_progress'? group=EString)
	 * </pre>
	 */
	protected void sequence_Concurrency(ISerializationContext context, Concurrency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Container returns Container
	 *
	 * Constraint:
	 *     (
	 *         image=EString 
	 *         credential=Credentials? 
	 *         envs+=Env* 
	 *         (ports+=EString ports+=EString*)? 
	 *         (volumes+=EString volumes+=EString*)? 
	 *         options=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_Container(ISerializationContext context, Container semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Credentials returns Credentials
	 *
	 * Constraint:
	 *     (username=EString password=EString)
	 * </pre>
	 */
	protected void sequence_Credentials(ISerializationContext context, Credentials semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.CREDENTIALS__USERNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.CREDENTIALS__USERNAME));
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.CREDENTIALS__PASSWORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.CREDENTIALS__PASSWORD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCredentialsAccess().getUsernameEStringParserRuleCall_1_2_0(), semanticObject.getUsername());
		feeder.accept(grammarAccess.getCredentialsAccess().getPasswordEStringParserRuleCall_1_4_0(), semanticObject.getPassword());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DefaultSetting returns DefaultSetting
	 *
	 * Constraint:
	 *     (shell=EString workingDirectory=EString)
	 * </pre>
	 */
	protected void sequence_DefaultSetting(ISerializationContext context, DefaultSetting semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.DEFAULT_SETTING__SHELL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.DEFAULT_SETTING__SHELL));
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.DEFAULT_SETTING__WORKING_DIRECTORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.DEFAULT_SETTING__WORKING_DIRECTORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefaultSettingAccess().getShellEStringParserRuleCall_1_2_0(), semanticObject.getShell());
		feeder.accept(grammarAccess.getDefaultSettingAccess().getWorkingDirectoryEStringParserRuleCall_1_4_0(), semanticObject.getWorkingDirectory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Docker
	 *     Docker returns Docker
	 *
	 * Constraint:
	 *     (
	 *         uses=EString 
	 *         image=EString 
	 *         pre_entrypoint=EString? 
	 *         entrypoint=EString? 
	 *         post_entrypoint=EString? 
	 *         (args+=EString args+=EString*)? 
	 *         composite_action+=Step* 
	 *         with+=InputParams* 
	 *         with_inputPair=InputPair? 
	 *         envs+=Env*
	 *     )
	 * </pre>
	 */
	protected void sequence_Docker(ISerializationContext context, Docker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Env returns Env
	 *
	 * Constraint:
	 *     (key=EString value=EString)
	 * </pre>
	 */
	protected void sequence_Env(ISerializationContext context, Env semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.ENV__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.ENV__KEY));
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.ENV__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.ENV__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvAccess().getKeyEStringParserRuleCall_1_2_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getEnvAccess().getValueEStringParserRuleCall_1_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Environment returns Environment
	 *
	 * Constraint:
	 *     (name=EString url=EString?)
	 * </pre>
	 */
	protected void sequence_Environment(ISerializationContext context, Environment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     If returns If
	 *
	 * Constraint:
	 *     condition=EString
	 * </pre>
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.IF__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.IF__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfAccess().getConditionEStringParserRuleCall_1_2_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InputPair returns InputPair
	 *
	 * Constraint:
	 *     (args=EString? entrypoint=EString?)
	 * </pre>
	 */
	protected void sequence_InputPair(ISerializationContext context, InputPair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InputParams returns InputParams
	 *
	 * Constraint:
	 *     (key=EString value=EString)
	 * </pre>
	 */
	protected void sequence_InputParams(ISerializationContext context, InputParams semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.INPUT_PARAMS__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.INPUT_PARAMS__KEY));
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.INPUT_PARAMS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.INPUT_PARAMS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputParamsAccess().getKeyEStringParserRuleCall_1_2_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getInputParamsAccess().getValueEStringParserRuleCall_1_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Input returns Input
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         isRequired?='isRequired'? 
	 *         type=INPUT_TYPES? 
	 *         (options+=EString options+=EString*)? 
	 *         description=EString? 
	 *         default=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Job returns Job
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         permissions+=Permission* 
	 *         need=Need? 
	 *         if=If? 
	 *         runner=Runs_On? 
	 *         environment=Environment? 
	 *         concurrency=Concurrency? 
	 *         outputs+=Output* 
	 *         envs+=Env* 
	 *         defaultsetting=DefaultSetting? 
	 *         timeout_minutes=EInt? 
	 *         continue_on_error=EString? 
	 *         container=Container? 
	 *         services+=Service* 
	 *         actions+=Action* 
	 *         secrets+=Secret* 
	 *         strategy=Strategy? 
	 *         steps+=Step+
	 *     )
	 * </pre>
	 */
	protected void sequence_Job(ISerializationContext context, Job semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MatrixConfig returns MatrixConfig
	 *
	 * Constraint:
	 *     (key=EString values+=EString values+=EString* type=MATRIX_CONFIG_TYPE?)
	 * </pre>
	 */
	protected void sequence_MatrixConfig(ISerializationContext context, MatrixConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Need returns Need
	 *
	 * Constraint:
	 *     (jobs+=EString jobs+=EString*)
	 * </pre>
	 */
	protected void sequence_Need(ISerializationContext context, Need semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Output returns Output
	 *
	 * Constraint:
	 *     (name=EString value=EString description=EString?)
	 * </pre>
	 */
	protected void sequence_Output(ISerializationContext context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     parameter=EString
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, gHA_metamodel.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.PARAMETER__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.PARAMETER__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getParameterEStringParserRuleCall_1_2_0(), semanticObject.getParameter());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Path returns Path
	 *
	 * Constraint:
	 *     (name=EString ignore?='ignore'?)
	 * </pre>
	 */
	protected void sequence_Path(ISerializationContext context, Path semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Permission returns Permission
	 *
	 * Constraint:
	 *     (readAll?='readAll'? writeAll?='writeAll'? disableAll?='disableAll'? permission=PERMISSIONS scope=PERMISSION_SCOPES)
	 * </pre>
	 */
	protected void sequence_Permission(ISerializationContext context, Permission semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pipeline returns Pipeline
	 *
	 * Constraint:
	 *     (
	 *         name=EString? 
	 *         run_name=EString? 
	 *         envs+=Env* 
	 *         permissions+=Permission* 
	 *         defaultsetting=DefaultSetting? 
	 *         concurrency=Concurrency? 
	 *         triggers+=Trigger* 
	 *         jobs+=Job+
	 *     )
	 * </pre>
	 */
	protected void sequence_Pipeline(ISerializationContext context, Pipeline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns PullTargetTrigger
	 *     PullTargetTrigger returns PullTargetTrigger
	 *
	 * Constraint:
	 *     ((activityType+=WEBHOOK_ACTIVITY_TYPES activityType+=WEBHOOK_ACTIVITY_TYPES*)? branches+=Branch* paths+=Path*)
	 * </pre>
	 */
	protected void sequence_PullTargetTrigger(ISerializationContext context, PullTargetTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns PullTrigger
	 *     PullTrigger returns PullTrigger
	 *
	 * Constraint:
	 *     ((activityType+=WEBHOOK_ACTIVITY_TYPES activityType+=WEBHOOK_ACTIVITY_TYPES*)? branches+=Branch* paths+=Path*)
	 * </pre>
	 */
	protected void sequence_PullTrigger(ISerializationContext context, PullTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns PushTrigger
	 *     PushTrigger returns PushTrigger
	 *
	 * Constraint:
	 *     (branches+=Branch* tags+=Tag* paths+=Path*)
	 * </pre>
	 */
	protected void sequence_PushTrigger(ISerializationContext context, PushTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns RestoreCache
	 *     RestoreCache returns RestoreCache
	 *
	 * Constraint:
	 *     (
	 *         uses='actions/cache/restore@v3' 
	 *         lookup_only?='lookup_only'? 
	 *         fail_on_cache_miss?='fail_on_cache_miss'? 
	 *         key=EString 
	 *         paths+=EString 
	 *         paths+=EString* 
	 *         (restore_keys+=EString restore_keys+=EString*)? 
	 *         composite_action+=Step* 
	 *         with+=InputParams* 
	 *         with_inputPair=InputPair?
	 *     )
	 * </pre>
	 */
	protected void sequence_RestoreCache(ISerializationContext context, RestoreCache semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Runs_On returns Runs_On
	 *
	 * Constraint:
	 *     ((labels+=EString labels+=EString*)? group=EString?)
	 * </pre>
	 */
	protected void sequence_Runs_On(ISerializationContext context, Runs_On semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns SaveCache
	 *     SaveCache returns SaveCache
	 *
	 * Constraint:
	 *     (
	 *         uses='actions/cache/save@v3' 
	 *         key=EString 
	 *         paths+=EString 
	 *         paths+=EString* 
	 *         upload_chunk_size=EString? 
	 *         composite_action+=Step* 
	 *         with+=InputParams* 
	 *         with_inputPair=InputPair?
	 *     )
	 * </pre>
	 */
	protected void sequence_SaveCache(ISerializationContext context, SaveCache semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns ScheduleTrigger
	 *     ScheduleTrigger returns ScheduleTrigger
	 *
	 * Constraint:
	 *     cron=EString
	 * </pre>
	 */
	protected void sequence_ScheduleTrigger(ISerializationContext context, ScheduleTrigger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.SCHEDULE_TRIGGER__CRON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.SCHEDULE_TRIGGER__CRON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScheduleTriggerAccess().getCronEStringParserRuleCall_1_2_0(), semanticObject.getCron());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Secret returns Secret
	 *
	 * Constraint:
	 *     (name=EString required?='required'? key=EString value=EString)
	 * </pre>
	 */
	protected void sequence_Secret(ISerializationContext context, Secret semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (name=EString container=Container)
	 * </pre>
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.SERVICE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.SERVICE__NAME));
			if (transientValues.isValueTransient(semanticObject, GHA_metamodelPackage.Literals.SERVICE__CONTAINER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GHA_metamodelPackage.Literals.SERVICE__CONTAINER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getServiceAccess().getNameEStringParserRuleCall_1_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getServiceAccess().getContainerContainerParserRuleCall_1_3_0(), semanticObject.getContainer());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns StandardEventTrigger
	 *     StandardEventTrigger returns StandardEventTrigger
	 *
	 * Constraint:
	 *     ((activityType+=WEBHOOK_ACTIVITY_TYPES activityType+=WEBHOOK_ACTIVITY_TYPES*)? event=EVENTS)
	 * </pre>
	 */
	protected void sequence_StandardEventTrigger(ISerializationContext context, StandardEventTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns Step
	 *
	 * Constraint:
	 *     (
	 *         name=EString? 
	 *         if=If? 
	 *         actions+=Action* 
	 *         shell=EString? 
	 *         working_directory=EString? 
	 *         envs+=Env* 
	 *         continue_on_error?='continue-on-error'? 
	 *         timeout_minutes=EShort? 
	 *         commands+=Command+ 
	 *         parameters+=Parameter*
	 *     )
	 * </pre>
	 */
	protected void sequence_Step(ISerializationContext context, Step semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Strategy returns Strategy
	 *
	 * Constraint:
	 *     (max_parallel=EShort? fail_fast?='fail_fast'? configs+=MatrixConfig*)
	 * </pre>
	 */
	protected void sequence_Strategy(ISerializationContext context, Strategy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Tag returns Tag
	 *
	 * Constraint:
	 *     (name=EString ignore?='ignore'?)
	 * </pre>
	 */
	protected void sequence_Tag(ISerializationContext context, Tag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns WorkflowCallTrigger
	 *     WorkflowCallTrigger returns WorkflowCallTrigger
	 *
	 * Constraint:
	 *     (inputs+=Input* outputs+=Output* secrets+=Secret*)
	 * </pre>
	 */
	protected void sequence_WorkflowCallTrigger(ISerializationContext context, WorkflowCallTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns WorkflowDispatchTrigger
	 *     WorkflowDispatchTrigger returns WorkflowDispatchTrigger
	 *
	 * Constraint:
	 *     inputs+=Input*
	 * </pre>
	 */
	protected void sequence_WorkflowDispatchTrigger(ISerializationContext context, WorkflowDispatchTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns WorkflowRunTrigger
	 *     WorkflowRunTrigger returns WorkflowRunTrigger
	 *
	 * Constraint:
	 *     (workflow=EString type=EString branches+=Branch*)
	 * </pre>
	 */
	protected void sequence_WorkflowRunTrigger(ISerializationContext context, WorkflowRunTrigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

/*
 * generated by Xtext 2.34.0
 */
package org.xtext.example.circleci.serializer;

import circleCI_metamodel.AddSSHKeys;
import circleCI_metamodel.AttachWorkspace;
import circleCI_metamodel.Branch;
import circleCI_metamodel.Checkout;
import circleCI_metamodel.CircleCI_metamodelPackage;
import circleCI_metamodel.Command;
import circleCI_metamodel.Docker;
import circleCI_metamodel.Docker_Auth;
import circleCI_metamodel.Docker_Aws_Auths;
import circleCI_metamodel.Environment;
import circleCI_metamodel.Job;
import circleCI_metamodel.JobWorkflow;
import circleCI_metamodel.MacOs;
import circleCI_metamodel.Machine;
import circleCI_metamodel.Matrix;
import circleCI_metamodel.MatrixParams;
import circleCI_metamodel.Orb;
import circleCI_metamodel.Parameters;
import circleCI_metamodel.PersistToWorkspace;
import circleCI_metamodel.Pipeline;
import circleCI_metamodel.RestoreCache;
import circleCI_metamodel.Run;
import circleCI_metamodel.RunCommand;
import circleCI_metamodel.SaveCache;
import circleCI_metamodel.SetupRemoteDocker;
import circleCI_metamodel.StoreArtifact;
import circleCI_metamodel.StoreTestResults;
import circleCI_metamodel.Trigger;
import circleCI_metamodel.When_Unless;
import circleCI_metamodel.Workflow;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.circleci.services.CircleciGrammarAccess;

@SuppressWarnings("all")
public class CircleciSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CircleciGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CircleCI_metamodelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CircleCI_metamodelPackage.ADD_SSH_KEYS:
				sequence_AddSSHKeys(context, (AddSSHKeys) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.ATTACH_WORKSPACE:
				sequence_AttachWorkspace(context, (AttachWorkspace) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.BRANCH:
				sequence_Branch(context, (Branch) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.CHECKOUT:
				sequence_Checkout(context, (Checkout) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.DOCKER:
				sequence_Docker(context, (Docker) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.DOCKER_AUTH:
				sequence_Docker_Auth(context, (Docker_Auth) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.DOCKER_AWS_AUTHS:
				sequence_Docker_Aws_Auths(context, (Docker_Aws_Auths) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.ENVIRONMENT:
				sequence_Environment(context, (Environment) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.JOB:
				sequence_Job(context, (Job) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.JOB_WORKFLOW:
				sequence_JobWorkflow(context, (JobWorkflow) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.MAC_OS:
				sequence_MacOs(context, (MacOs) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.MACHINE:
				sequence_Machine(context, (Machine) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.MATRIX:
				sequence_Matrix(context, (Matrix) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.MATRIX_PARAMS:
				sequence_MatrixParams(context, (MatrixParams) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.ORB:
				sequence_Orb(context, (Orb) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.PARAMETER:
				sequence_Parameter(context, (circleCI_metamodel.Parameter) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.PARAMETERS:
				sequence_Parameters(context, (Parameters) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.PERSIST_TO_WORKSPACE:
				sequence_PersistToWorkspace(context, (PersistToWorkspace) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.PIPELINE:
				sequence_Pipeline(context, (Pipeline) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.RESTORE_CACHE:
				sequence_RestoreCache(context, (RestoreCache) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.RUN:
				sequence_Run(context, (Run) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.RUN_COMMAND:
				sequence_RunCommand(context, (RunCommand) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.SAVE_CACHE:
				sequence_SaveCache(context, (SaveCache) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.SETUP_REMOTE_DOCKER:
				sequence_SetupRemoteDocker(context, (SetupRemoteDocker) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.STORE_ARTIFACT:
				sequence_StoreArtifact(context, (StoreArtifact) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.STORE_TEST_RESULTS:
				sequence_StoreTestResults(context, (StoreTestResults) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.TRIGGER:
				sequence_Trigger(context, (Trigger) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.WHEN_UNLESS:
				sequence_When_Unless(context, (When_Unless) semanticObject); 
				return; 
			case CircleCI_metamodelPackage.WORKFLOW:
				sequence_Workflow(context, (Workflow) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns AddSSHKeys
	 *     AddSSHKeys returns AddSSHKeys
	 *
	 * Constraint:
	 *     (name=EString? (fingerprints+=EString fingerprints+=EString)?)
	 * </pre>
	 */
	protected void sequence_AddSSHKeys(ISerializationContext context, AddSSHKeys semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns AttachWorkspace
	 *     AttachWorkspace returns AttachWorkspace
	 *
	 * Constraint:
	 *     (name=EString? at=EString)
	 * </pre>
	 */
	protected void sequence_AttachWorkspace(ISerializationContext context, AttachWorkspace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Branch returns Branch
	 *
	 * Constraint:
	 *     (name=EString branch=BRANCH_TYPE)
	 * </pre>
	 */
	protected void sequence_Branch(ISerializationContext context, Branch semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.BRANCH__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.BRANCH__NAME));
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.BRANCH__BRANCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.BRANCH__BRANCH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBranchAccess().getNameEStringParserRuleCall_1_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBranchAccess().getBranchBRANCH_TYPEEnumRuleCall_1_4_0(), semanticObject.getBranch());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns Checkout
	 *     Checkout returns Checkout
	 *
	 * Constraint:
	 *     (name=EString? path=EString?)
	 * </pre>
	 */
	protected void sequence_Checkout(ISerializationContext context, Checkout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Command
	 *
	 * Constraint:
	 *     (name=EString description=EString? parameters+=Parameter* steps+=Step+)
	 * </pre>
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Docker_Auth returns Docker_Auth
	 *
	 * Constraint:
	 *     (username=EString password=EString)
	 * </pre>
	 */
	protected void sequence_Docker_Auth(ISerializationContext context, Docker_Auth semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.DOCKER_AUTH__USERNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.DOCKER_AUTH__USERNAME));
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.DOCKER_AUTH__PASSWORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.DOCKER_AUTH__PASSWORD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDocker_AuthAccess().getUsernameEStringParserRuleCall_1_2_0(), semanticObject.getUsername());
		feeder.accept(grammarAccess.getDocker_AuthAccess().getPasswordEStringParserRuleCall_1_4_0(), semanticObject.getPassword());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Docker_Aws_Auths returns Docker_Aws_Auths
	 *
	 * Constraint:
	 *     (aws_access_key_id=EString aws_secret_access_key=EString)
	 * </pre>
	 */
	protected void sequence_Docker_Aws_Auths(ISerializationContext context, Docker_Aws_Auths semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.DOCKER_AWS_AUTHS__AWS_ACCESS_KEY_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.DOCKER_AWS_AUTHS__AWS_ACCESS_KEY_ID));
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.DOCKER_AWS_AUTHS__AWS_SECRET_ACCESS_KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.DOCKER_AWS_AUTHS__AWS_SECRET_ACCESS_KEY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDocker_Aws_AuthsAccess().getAws_access_key_idEStringParserRuleCall_1_2_0(), semanticObject.getAws_access_key_id());
		feeder.accept(grammarAccess.getDocker_Aws_AuthsAccess().getAws_secret_access_keyEStringParserRuleCall_1_4_0(), semanticObject.getAws_secret_access_key());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Executor returns Docker
	 *     Docker returns Docker
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         image=EString 
	 *         resourceClass=EString 
	 *         shell=EString? 
	 *         working_directory=EString? 
	 *         (entrypoint+=EString entrypoint+=EString*)? 
	 *         (command+=EString command+=EString*)? 
	 *         user=EString? 
	 *         environments+=Environment* 
	 *         docker_auth=Docker_Auth? 
	 *         docker_aws_auth=Docker_Aws_Auths?
	 *     )
	 * </pre>
	 */
	protected void sequence_Docker(ISerializationContext context, Docker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Environment returns Environment
	 *
	 * Constraint:
	 *     (key=EString value=EString)
	 * </pre>
	 */
	protected void sequence_Environment(ISerializationContext context, Environment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.ENVIRONMENT__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.ENVIRONMENT__KEY));
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.ENVIRONMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.ENVIRONMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvironmentAccess().getKeyEStringParserRuleCall_1_2_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getEnvironmentAccess().getValueEStringParserRuleCall_1_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JobWorkflow returns JobWorkflow
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         approvalJob?='approvalJob'? 
	 *         (requires+=EString requires+=EString*)? 
	 *         (context+=EString context+=EString*)? 
	 *         branches+=Branch* 
	 *         matrix=Matrix?
	 *     )
	 * </pre>
	 */
	protected void sequence_JobWorkflow(ISerializationContext context, JobWorkflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Job returns Job
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         parallelism=EShort? 
	 *         reuseExecutor=EString 
	 *         environments+=Environment* 
	 *         steps+=Step+ 
	 *         parameters+=Parameter* 
	 *         executors+=Executor*
	 *     )
	 * </pre>
	 */
	protected void sequence_Job(ISerializationContext context, Job semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Executor returns MacOs
	 *     MacOs returns MacOs
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         xcode=EString 
	 *         resourceClass=EString 
	 *         shell=EString? 
	 *         working_directory=EString? 
	 *         environments+=Environment*
	 *     )
	 * </pre>
	 */
	protected void sequence_MacOs(ISerializationContext context, MacOs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Executor returns Machine
	 *     Machine returns Machine
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         image=EString 
	 *         docker_layer_caching?='docker_layer_caching'? 
	 *         resourceClass=EString 
	 *         shell=EString? 
	 *         working_directory=EString? 
	 *         environments+=Environment*
	 *     )
	 * </pre>
	 */
	protected void sequence_Machine(ISerializationContext context, Machine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MatrixParams returns MatrixParams
	 *
	 * Constraint:
	 *     (key=EString values+=EString values+=EString*)
	 * </pre>
	 */
	protected void sequence_MatrixParams(ISerializationContext context, MatrixParams semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Matrix returns Matrix
	 *
	 * Constraint:
	 *     (alias=EString? matrix_exclude+=MatrixParams* matrix_params+=MatrixParams+)
	 * </pre>
	 */
	protected void sequence_Matrix(ISerializationContext context, Matrix semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Orb returns Orb
	 *
	 * Constraint:
	 *     (key=EString value=EString)
	 * </pre>
	 */
	protected void sequence_Orb(ISerializationContext context, Orb semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.ORB__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.ORB__KEY));
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.ORB__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.ORB__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrbAccess().getKeyEStringParserRuleCall_1_2_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getOrbAccess().getValueEStringParserRuleCall_1_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=EString type=PARAMETER_TYPES default=EString? description=EString? (enumValues+=EString enumValues+=EString*)?)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, circleCI_metamodel.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameters returns Parameters
	 *
	 * Constraint:
	 *     parameter=EString
	 * </pre>
	 */
	protected void sequence_Parameters(ISerializationContext context, Parameters semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.PARAMETERS__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.PARAMETERS__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParametersAccess().getParameterEStringParserRuleCall_1_2_0(), semanticObject.getParameter());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns PersistToWorkspace
	 *     PersistToWorkspace returns PersistToWorkspace
	 *
	 * Constraint:
	 *     (name=EString? root=EString paths+=EString paths+=EString*)
	 * </pre>
	 */
	protected void sequence_PersistToWorkspace(ISerializationContext context, PersistToWorkspace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pipeline returns Pipeline
	 *
	 * Constraint:
	 *     (
	 *         setup?='setup'? 
	 *         version=EString 
	 *         orbs+=Orb* 
	 *         commands+=Command* 
	 *         executors+=Executor+ 
	 *         jobs+=Job+ 
	 *         workflow=Workflow?
	 *     )
	 * </pre>
	 */
	protected void sequence_Pipeline(ISerializationContext context, Pipeline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns RestoreCache
	 *     RestoreCache returns RestoreCache
	 *
	 * Constraint:
	 *     (name=EString? key=EString keys+=EString keys+=EString*)
	 * </pre>
	 */
	protected void sequence_RestoreCache(ISerializationContext context, RestoreCache semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RunCommand returns RunCommand
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_RunCommand(ISerializationContext context, RunCommand semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.RUN_COMMAND__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.RUN_COMMAND__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRunCommandAccess().getNameEStringParserRuleCall_2_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns Run
	 *     Run returns Run
	 *
	 * Constraint:
	 *     (
	 *         name=EString? 
	 *         background?='background'? 
	 *         when=WHEN_TYPE? 
	 *         working_directory=EString? 
	 *         no_output_timeout=EString? 
	 *         shell=EString? 
	 *         environments+=Environment* 
	 *         run_commands+=RunCommand+ 
	 *         parameters+=Parameters*
	 *     )
	 * </pre>
	 */
	protected void sequence_Run(ISerializationContext context, Run semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns SaveCache
	 *     SaveCache returns SaveCache
	 *
	 * Constraint:
	 *     (name=EString? paths+=EString paths+=EString* key=EString when=WHEN_TYPE?)
	 * </pre>
	 */
	protected void sequence_SaveCache(ISerializationContext context, SaveCache semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns SetupRemoteDocker
	 *     SetupRemoteDocker returns SetupRemoteDocker
	 *
	 * Constraint:
	 *     (name=EString? docker_layer_caching?='docker_layer_caching'? version=EString?)
	 * </pre>
	 */
	protected void sequence_SetupRemoteDocker(ISerializationContext context, SetupRemoteDocker semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns StoreArtifact
	 *     StoreArtifact returns StoreArtifact
	 *
	 * Constraint:
	 *     (name=EString? path=EString destination=EString?)
	 * </pre>
	 */
	protected void sequence_StoreArtifact(ISerializationContext context, StoreArtifact semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns StoreTestResults
	 *     StoreTestResults returns StoreTestResults
	 *
	 * Constraint:
	 *     (name=EString? path=EString)
	 * </pre>
	 */
	protected void sequence_StoreTestResults(ISerializationContext context, StoreTestResults semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns Trigger
	 *
	 * Constraint:
	 *     cron=EString
	 * </pre>
	 */
	protected void sequence_Trigger(ISerializationContext context, Trigger semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CircleCI_metamodelPackage.Literals.TRIGGER__CRON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CircleCI_metamodelPackage.Literals.TRIGGER__CRON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTriggerAccess().getCronEStringParserRuleCall_1_2_0(), semanticObject.getCron());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns When_Unless
	 *     When_Unless returns When_Unless
	 *
	 * Constraint:
	 *     (name=EString? condition=EString when_step+=Step+ unless_step+=Step*)
	 * </pre>
	 */
	protected void sequence_When_Unless(ISerializationContext context, When_Unless semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns Workflow
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         version=EString 
	 *         triggers+=Trigger* 
	 *         branches+=Branch* 
	 *         when_unless=When_Unless? 
	 *         jobworkflow+=JobWorkflow+
	 *     )
	 * </pre>
	 */
	protected void sequence_Workflow(ISerializationContext context, Workflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

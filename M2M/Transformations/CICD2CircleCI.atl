-- @path CICD=/CICD_metamodel/model/cICD_metamodel.ecore
-- @path CircleCI=/CircleCI_metamodel/model/circleCI_metamodel.ecore

module CICD2CircleCI;
create OUT : CircleCI from IN : CICD;

rule Pipeline2Pipeline {
	from
		s : CICD!Pipeline
	to
		t : CircleCI!Pipeline(
			version <- '2.1',
			setup <- false,
			jobs <- s.jobs->collect(job | thisModule.Job2Job(job, 
                                            if s.agents->notEmpty() and s.agents->first().labels->notEmpty() then 
                                                s.agents->first().labels->first()
                                            else 
                                                ''
                                            endif)),
			commands <- s.inputs ->collect(i | thisModule.Input2Command(i)),
			workflows <- thisModule.ScheduleTrigger2Workflow(s),
			executors <- s.agents ->collect(agent | thisModule.DockerContainer2Docker(agent.container, agent.labels->first()))
		)
}

lazy rule Input2Command {
    from
        s : CICD!Input
    to
        t : CircleCI!Command (
            name <- 'Com' + s.name,
			description <- OclUndefined,
			parameters <- thisModule.Input2Parameter(s),
			steps <- thisModule.DummyStep(s)
        )
}

lazy rule DummyStep {
    from
        s : CICD!Input
    to
        t : CircleCI!Run (
            name <- OclUndefined,
			when <- #on_success,
			background <- false,
			working_directory <- OclUndefined,
			no_output_timeout <- OclUndefined,
			shell <- OclUndefined,
			run_commands <- thisModule.DummyRunCommand(s)
        )
}

lazy rule DummyRunCommand {
    from
        s : CICD!Input
    to
        t : CircleCI!RunCommand (
            name <- 'change this command to run'
        )
}

lazy rule Input2Parameter {
	from
		s : CICD!Input
	to
		t : CircleCI!Parameter(
			name <- s.name,
			default <- 
				if not s.default.oclIsUndefined() then 
					s.default
				else 
					OclUndefined 
				endif,
			description <-
				if not s.description.oclIsUndefined() then
					s.description
				else
					OclUndefined
				endif,
			enumValues <- s.values,
			type <-
				if s.type = #STRING then
					#STRING
				else if s.type = #NUMBER then
					#INTEGER
				else if s.type = #BOOLEAN then
					#BOOLEAN
				else if s.type = #CHOICE then
					#ENUM
				else
					#STRING
				endif
				endif
				endif
				endif
		)
}

lazy rule ScheduleTrigger2Workflow {
    from
        s : CICD!Pipeline
    to
        t : CircleCI!Workflow (
            name <- 'build-and-deploy',
			version <- '2.1',
			triggers <- s.triggers -> collect(trigger | thisModule.ScheduleTrigger2ScheduleTrigger(trigger)),
			jobworkflow <- s.jobs -> collect(job | thisModule.Job2JobWorkflow(job))
        )
}

lazy rule ScheduleTrigger2ScheduleTrigger {
    from
        s : CICD!ScheduleTrigger
    to
        t : CircleCI!Trigger (
            cron <- s.timer
        )
}

lazy rule Job2JobWorkflow {
    from
        s : CICD!Job
    to
        t : CircleCI!JobWorkflow (
            name <- s.name,
			requires <- if s.requireJobs->notEmpty() then 
					s.requireJobs
				else 
					OclUndefined 
				endif, 
			context <- OclUndefined,
			approvalJob <- false,
			matrix <- if not s.matrix.oclIsUndefined() then 
					thisModule.Matrix2Matrix(s.matrix)
				else 
					 OclUndefined
				endif
        )
}

lazy rule Matrix2Matrix {
    from
        s : CICD!Matrix
    to
        t : CircleCI!Matrix (
            alias <- s.name,
			matrix_params <- s.configs->select(config | (config.type = #INCLUDE or config.type = #DEFAULT)),
			matrix_exclude <- s.configs->select(config | config.type = #EXCLUDE)
        )
}

rule MatrixConfig2MatrixParams {
    from
        s : CICD!MatrixConfig
    to
        t : CircleCI!MatrixParams (
            key <- s.name,
			values <- s.values
        )
}

lazy rule Job2Job {
    from
        s : CICD!Job,
		label : String
    to
        t : CircleCI!Job (
            name <- s.name,
			reuseExecutor <- if label <> '' then label else OclUndefined endif,
			reuseCommand <- OclUndefined,
			executors <- s.agents ->collect(agent | thisModule.DockerContainer2Docker(agent.container, agent.labels->first())),
            parallelism <- OclUndefined,
            environments <- s.environments ->collect(env | thisModule.transformEnvironment(env)),
			steps <- if s.steps->notEmpty() and s.IfStep->notEmpty() and s.artifacts->notEmpty() then
						s.steps->union(s.IfStep)->union(s.artifacts)->collect(step | 
							if step.oclIsTypeOf(CICD!IfStep) then
								thisModule.IfStep2WhenUnless(step)
								
							else if step.oclIsTypeOf(CICD!Artifact) then
								thisModule.Artifact2StoreArtifact(step)
								
							else 
								step.transformStepWithCache()
							endif
							endif	
						)
					else if s.steps->isEmpty() and s.IfStep->notEmpty() and s.artifacts->notEmpty() then
						s.IfStep->union(s.artifacts)->collect(step | 
							if step.oclIsTypeOf(CICD!IfStep) then
								thisModule.IfStep2WhenUnless(step)
								
							else 
								thisModule.Artifact2StoreArtifact(step)
							endif	
						)
					else if s.steps->notEmpty() and s.IfStep->isEmpty() and s.artifacts->notEmpty() then
						s.steps->union(s.artifacts)->collect(step | 
							if step.oclIsTypeOf(CICD!Artifact) then
								thisModule.Artifact2StoreArtifact(step)
								
							else 
								step.transformStepWithCache()
							endif	
						)
					else if s.steps->notEmpty() and s.IfStep->notEmpty() and s.artifacts->isEmpty() then
						s.steps->union(s.IfStep)->collect(step | 
							if step.oclIsTypeOf(CICD!IfStep) then
								thisModule.IfStep2WhenUnless(step)
								
							else 
								step.transformStepWithCache()
							endif	
						)
					else if s.steps->notEmpty() and s.IfStep->isEmpty() and s.artifacts->isEmpty() then
						s.steps->collect(step | step.transformStepWithCache())
					
					else if s.steps->isEmpty() and s.IfStep->notEmpty() and s.artifacts->isEmpty() then
						s.IfStep->collect(step | thisModule.IfStep2WhenUnless(step))
					
					else if s.steps->isEmpty() and s.IfStep->isEmpty() and s.artifacts->notEmpty() then
						s.artifacts->collect(step | thisModule.Artifact2StoreArtifact(step))
					else
						OclUndefined
					endif
					endif
					endif
					endif
					endif
					endif
					endif
        )
}



lazy rule IfStep2WhenUnless {
    from
        s : CICD!IfStep
    to
        t : CircleCI!When_Unless (
            name <- OclUndefined,
			condition <- s.condition,
			when_step <- if s.if_steps->notEmpty() then
							s.if_steps->collect(step | step.transformStepWithCache())
						else
							OclUndefined
						endif,
			unless_step <- if s.else_steps->notEmpty() then
							s.else_steps->collect(step | step.transformStepWithCache())
						else
							OclUndefined
						endif
        )
}

lazy rule Artifact2StoreArtifact {
    from
        s : CICD!Artifact
    to
        t : CircleCI!StoreArtifact (
            name <- OclUndefined,
			path <- s.path->first(),
			destination <- OclUndefined
        )
}

lazy rule Step2SRun {
    from
        s : CICD!Step
    to
        t : CircleCI!Run (
            name <- OclUndefined,
			when <- #on_success,
			background <- false,
			working_directory <- OclUndefined,
			no_output_timeout <- OclUndefined,
			shell <- OclUndefined,
			run_commands <- s.commands,
			parameters <- s.parameters
        )
}

lazy rule Cache2SaveCache {
    from
        s : CICD!Cache
    to
        t : CircleCI!SaveCache (
        	name <- OclUndefined,
            paths <- s.paths,
			key <- s.key,
			when <- #on_success
        )
}

lazy rule Cache2RestoreCache {
    from
        s : CICD!Cache
    to
        t : CircleCI!RestoreCache (
        	name <- OclUndefined,
            key <- s.key,
            keys <- s.keys
        )
}


lazy rule transformEnvironment {
    from
        s : CICD!Environment
    to
        t : CircleCI!Environment (
            key <- s.key,
            value <- s.value
        )
}


lazy rule DockerContainer2Docker {
    from
        s : CICD!DockerContainer,
		label : String
    to
        t : CircleCI!Docker (
        	name <- label,
            image <- s.image,
			resourceClass <- #medium,
			shell <- OclUndefined,
			working_directory <- OclUndefined,
			entrypoint <- OclUndefined,
			command <- OclUndefined,
			user <- OclUndefined,
			docker_auth <- if not (s.username->oclIsUndefined() and s.password->oclIsUndefined()) then 
								thisModule.transformDockerAuth(s)
							else
								OclUndefined
							endif,
			environments <- s.environments ->collect(env | thisModule.transformEnvironment(env))
        )
}

lazy rule transformDockerAuth {
    from
        s : CICD!DockerContainer
    to
        t : CircleCI!Docker_Auth (
            username <- s.username,
			password <- s.password
        )
}


rule transformCommand {
    from
        s : CICD!Command
    to
        t : CircleCI!RunCommand (
            name <- s.name
        )
}


rule transformParameters {
    from
        s : CICD!Parameters
    to
        t : CircleCI!Parameters (
            parameter <- s.parameter
        )
}

helper context CICD!Step def: transformStepWithCache() : Sequence(CircleCI!Run) =
    let cacheSteps : Sequence(CircleCI!Run) = 
        self.cache->collect(c |
            if c.mode = #STORE then
                thisModule.Cache2SaveCache(c)
            else
                thisModule.Cache2RestoreCache(c)
            endif
        )->flatten()
    in
    if self.cache->notEmpty() then
        cacheSteps->append(thisModule.Step2SRun(self))
    else
        Sequence{thisModule.Step2SRun(self)}
    endif;
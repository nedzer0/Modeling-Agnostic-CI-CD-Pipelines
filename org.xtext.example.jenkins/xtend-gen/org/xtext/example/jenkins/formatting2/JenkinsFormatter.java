/**
 * generated by Xtext 2.34.0
 */
package org.xtext.example.jenkins.formatting2;

import com.google.inject.Inject;
import java.util.Arrays;
import jenkins_metamodel.Agent;
import jenkins_metamodel.Environment;
import jenkins_metamodel.Input;
import jenkins_metamodel.Matrix;
import jenkins_metamodel.Option;
import jenkins_metamodel.Parameter_Directive;
import jenkins_metamodel.Pipeline;
import jenkins_metamodel.Post;
import jenkins_metamodel.Stage;
import jenkins_metamodel.StageOption;
import jenkins_metamodel.Step;
import jenkins_metamodel.Tool;
import jenkins_metamodel.Trigger;
import jenkins_metamodel.When;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.formatting2.AbstractFormatter2;
import org.eclipse.xtext.formatting2.IFormattableDocument;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.xbase.lib.Extension;
import org.xtext.example.jenkins.services.JenkinsGrammarAccess;

@SuppressWarnings("all")
public class JenkinsFormatter extends AbstractFormatter2 {
  @Inject
  @Extension
  private JenkinsGrammarAccess _jenkinsGrammarAccess;

  protected void _format(final Pipeline pipeline, @Extension final IFormattableDocument document) {
    EList<Agent> _agents = pipeline.getAgents();
    for (final Agent agent : _agents) {
      document.<Agent>format(agent);
    }
    EList<Option> _options = pipeline.getOptions();
    for (final Option option : _options) {
      document.<Option>format(option);
    }
    EList<Trigger> _triggers = pipeline.getTriggers();
    for (final Trigger trigger : _triggers) {
      document.<Trigger>format(trigger);
    }
    EList<Parameter_Directive> _parameter_directives = pipeline.getParameter_directives();
    for (final Parameter_Directive parameter_Directive : _parameter_directives) {
      document.<Parameter_Directive>format(parameter_Directive);
    }
    EList<Environment> _environments = pipeline.getEnvironments();
    for (final Environment environment : _environments) {
      document.<Environment>format(environment);
    }
    EList<Tool> _tools = pipeline.getTools();
    for (final Tool tool : _tools) {
      document.<Tool>format(tool);
    }
    EList<Stage> _stages = pipeline.getStages();
    for (final Stage stage : _stages) {
      document.<Stage>format(stage);
    }
    EList<Post> _post = pipeline.getPost();
    for (final Post post : _post) {
      document.<Post>format(post);
    }
  }

  protected void _format(final Stage stage, @Extension final IFormattableDocument document) {
    EList<Stage> _stages = stage.getStages();
    for (final Stage _stage : _stages) {
      document.<Stage>format(_stage);
    }
    EList<Agent> _agents = stage.getAgents();
    for (final Agent agent : _agents) {
      document.<Agent>format(agent);
    }
    EList<Step> _steps = stage.getSteps();
    for (final Step step : _steps) {
      document.<Step>format(step);
    }
    EList<Environment> _environments = stage.getEnvironments();
    for (final Environment environment : _environments) {
      document.<Environment>format(environment);
    }
    EList<Input> _inputs = stage.getInputs();
    for (final Input input : _inputs) {
      document.<Input>format(input);
    }
    EList<When> _when = stage.getWhen();
    for (final When when : _when) {
      document.<When>format(when);
    }
    EList<StageOption> _stage_options = stage.getStage_options();
    for (final StageOption stageOption : _stage_options) {
      document.<StageOption>format(stageOption);
    }
    document.<Matrix>format(stage.getMatrix());
  }

  public void format(final Object pipeline, final IFormattableDocument document) {
    if (pipeline instanceof XtextResource) {
      _format((XtextResource)pipeline, document);
      return;
    } else if (pipeline instanceof Pipeline) {
      _format((Pipeline)pipeline, document);
      return;
    } else if (pipeline instanceof Stage) {
      _format((Stage)pipeline, document);
      return;
    } else if (pipeline instanceof EObject) {
      _format((EObject)pipeline, document);
      return;
    } else if (pipeline == null) {
      _format((Void)null, document);
      return;
    } else if (pipeline != null) {
      _format(pipeline, document);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(pipeline, document).toString());
    }
  }
}
